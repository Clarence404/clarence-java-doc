import{_ as n,c as s,a as l,o as e}from"./app-B3Ybswz4.js";const i={};function t(o,a){return e(),s("div",null,a[0]||(a[0]=[l(`<h1 id="jvm-内存结构" tabindex="-1"><a class="header-anchor" href="#jvm-内存结构"><span>JVM 内存结构</span></a></h1><h2 id="程序计数器" tabindex="-1"><a class="header-anchor" href="#程序计数器"><span>程序计数器</span></a></h2><ul><li>每个线程私有，记录当前线程执行的字节码行号。</li><li>唯一不会发生 OutOfMemoryError 的区域。</li><li>执行 Native 方法时，计数器值为空（Undefined）。</li></ul><h2 id="java-虚拟机栈" tabindex="-1"><a class="header-anchor" href="#java-虚拟机栈"><span>Java 虚拟机栈</span></a></h2><ul><li>管理 Java 方法调用所需的栈帧。</li><li>每个线程私有。</li><li>栈帧包含：局部变量表、操作数栈、动态链接、方法出口。</li><li>异常：StackOverflowError（栈深度过大）、OutOfMemoryError（无法扩展栈）。</li></ul><h2 id="本地方法栈" tabindex="-1"><a class="header-anchor" href="#本地方法栈"><span>本地方法栈</span></a></h2><ul><li>为 JVM 调用 Native 方法服务。</li><li>与 Java 虚拟机栈类似，但服务于 Native 方法。</li><li>HotSpot VM 将两者合二为一。</li></ul><h2 id="堆" tabindex="-1"><a class="header-anchor" href="#堆"><span>堆</span></a></h2><ul><li>所有线程共享，存放对象实例。</li><li>分代管理：年轻代（Eden、Survivor）和老年代。</li><li>异常：OutOfMemoryError: Java heap space。</li><li>可通过 -Xms 和 -Xmx 调整大小。</li></ul><h2 id="方法区-metaspace" tabindex="-1"><a class="header-anchor" href="#方法区-metaspace"><span>方法区（MetaSpace）</span></a></h2><ul><li>存储类的结构信息、常量、静态变量等。</li><li>JDK8 之后使用元空间（MetaSpace）替代永久代。</li><li>元空间使用本地内存，默认无上限。</li><li>异常：OutOfMemoryError: Metaspace。</li></ul><h2 id="直接内存-direct-memory" tabindex="-1"><a class="header-anchor" href="#直接内存-direct-memory"><span>直接内存（Direct Memory）</span></a></h2><ul><li>堆外内存，通过 Unsafe.allocateMemory() 或 ByteBuffer.allocateDirect() 分配。</li><li>不受 JVM 堆内存限制，但受本机物理内存限制。</li><li>常用于 NIO 操作，避免在 Java 堆和 Native 堆之间复制数据。</li><li>可通过 -XX:MaxDirectMemorySize 限制大小。</li></ul><h2 id="逃逸分析" tabindex="-1"><a class="header-anchor" href="#逃逸分析"><span>逃逸分析</span></a></h2><ul><li>对象作用域分析，判断对象是否会逃逸出方法。</li><li>逃逸：对象被方法外部引用（返回值、赋值给静态变量、赋值给其他线程等）。</li><li>不逃逸：对象只在方法内部使用。</li></ul><h3 id="逃逸分析优化" tabindex="-1"><a class="header-anchor" href="#逃逸分析优化"><span>逃逸分析优化</span></a></h3><ol><li><strong>栈上分配</strong>：未逃逸对象分配在栈上，随栈帧销毁自动回收。</li><li><strong>标量替换</strong>：将对象拆解为基本类型，不创建对象。</li><li><strong>同步锁消除</strong>：未逃逸对象无需同步，消除锁。</li></ol><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">escapeAnalysis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// 未逃逸对象，可能被优化为栈上分配或标量替换</span></span>
<span class="line">    <span class="token class-name">Point</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>x <span class="token operator">+</span> p<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">public</span> <span class="token class-name">Point</span> <span class="token function">escape</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// 逃逸对象，必须在堆上分配</span></span>
<span class="line">    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="tlab-thread-local-allocation-buffer" tabindex="-1"><a class="header-anchor" href="#tlab-thread-local-allocation-buffer"><span>TLAB（Thread Local Allocation Buffer）</span></a></h2><ul><li>线程私有的分配缓冲区，减少多线程分配时的竞争。</li><li>默认大小为 Eden 区的 1%。</li><li>参数：-XX:TLABWasteTargetPercent（默认 1）。</li><li>分配流程：优先在 TLAB 分配，不足时在 Eden 区分配。</li></ul><h3 id="tlab-优势" tabindex="-1"><a class="header-anchor" href="#tlab-优势"><span>TLAB 优势</span></a></h3><ul><li>减少多线程竞争，提升分配性能。</li><li>避免频繁的 CAS 操作。</li><li>大多数对象在 TLAB 中分配，只有大对象才在共享区域分配。</li></ul><h2 id="jvm-内存分配策略" tabindex="-1"><a class="header-anchor" href="#jvm-内存分配策略"><span>JVM 内存分配策略</span></a></h2><ol><li><strong>对象优先在 Eden 区分配</strong>：新对象优先在年轻代 Eden 区分配。</li><li><strong>大对象直接进入老年代</strong>：超过 -XX:PretenureSizeThreshold 的对象直接进入老年代。</li><li><strong>长期存活对象进入老年代</strong>：经历 15 次 Minor GC 后进入老年代（-XX:MaxTenuringThreshold）。</li><li><strong>动态年龄判断</strong>：Survivor 区相同年龄对象大小总和 &gt; Survivor 区一半，年龄 &gt;= 该年龄的对象进入老年代。</li><li><strong>空间分配担保</strong>：Minor GC 前检查老年代最大可用连续空间是否大于新生代所有对象总和。</li></ol>`,24)]))}const p=n(i,[["render",t],["__file","01_jvm_memory.html.vue"]]),r=JSON.parse('{"path":"/jvm/01_jvm_memory.html","title":"JVM 内存结构","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"程序计数器","slug":"程序计数器","link":"#程序计数器","children":[]},{"level":2,"title":"Java 虚拟机栈","slug":"java-虚拟机栈","link":"#java-虚拟机栈","children":[]},{"level":2,"title":"本地方法栈","slug":"本地方法栈","link":"#本地方法栈","children":[]},{"level":2,"title":"堆","slug":"堆","link":"#堆","children":[]},{"level":2,"title":"方法区（MetaSpace）","slug":"方法区-metaspace","link":"#方法区-metaspace","children":[]},{"level":2,"title":"直接内存（Direct Memory）","slug":"直接内存-direct-memory","link":"#直接内存-direct-memory","children":[]},{"level":2,"title":"逃逸分析","slug":"逃逸分析","link":"#逃逸分析","children":[{"level":3,"title":"逃逸分析优化","slug":"逃逸分析优化","link":"#逃逸分析优化","children":[]}]},{"level":2,"title":"TLAB（Thread Local Allocation Buffer）","slug":"tlab-thread-local-allocation-buffer","link":"#tlab-thread-local-allocation-buffer","children":[{"level":3,"title":"TLAB 优势","slug":"tlab-优势","link":"#tlab-优势","children":[]}]},{"level":2,"title":"JVM 内存分配策略","slug":"jvm-内存分配策略","link":"#jvm-内存分配策略","children":[]}],"git":{"updatedTime":1771047071000,"contributors":[{"name":"hello0709","username":"hello0709","email":"1154937362@qq.com","commits":1,"url":"https://github.com/hello0709"}]},"filePathRelative":"jvm/01_jvm_memory.md"}');export{p as comp,r as data};
