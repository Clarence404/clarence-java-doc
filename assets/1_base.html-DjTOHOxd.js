import{_ as o,c,a as l,e,f as p,d as a,b as s,r as i,o as r}from"./app-BjUqaC1o.js";const u="/clarence-java-doc/assets/hashmap_hash_conflict-DfcWWAIJ.png",d="/clarence-java-doc/assets/LinkedHashMap-uNfJhtFw.png",k="/clarence-java-doc/assets/TreeMap-RKRumpct.png",h="/clarence-java-doc/assets/volatile-Bf3yqia0.png",m="/clarence-java-doc/assets/command_reformat-bUm8VFxM.png",v="/clarence-java-doc/assets/singleton_double_check-CQ3424ap.png",g="/clarence-java-doc/assets/threadlocal_usage-DJvxl6vh.png",b="/clarence-java-doc/assets/threadlocal_structure-Chz4M1CP.png",f={};function y(_,n){const t=i("RouteLink");return r(),c("div",null,[n[25]||(n[25]=l('<h1 id="java-基础" tabindex="-1"><a class="header-anchor" href="#java-基础"><span>Java 基础</span></a></h1><ul><li>API地址：<a href="https://docs.oracle.com/en/java/javase/" target="_blank" rel="noopener noreferrer">https://docs.oracle.com/en/java/javase/</a></li><li>源码地址：<a href="https://github.com/openjdk" target="_blank" rel="noopener noreferrer">https://github.com/openjdk</a></li></ul><h2 id="一、hashmap分析" tabindex="-1"><a class="header-anchor" href="#一、hashmap分析"><span>一、Hashmap分析</span></a></h2><p>HashMap 是一种基于哈希表的数据结构，它实现了 Map 接口，用于存储键值对 (key-value)。其基本原理如下：</p><h3 id="_1、哈希表-hash-table" tabindex="-1"><a class="header-anchor" href="#_1、哈希表-hash-table"><span>1、哈希表（Hash Table）</span></a></h3><p>HashMap 是基于哈希表实现的，哈希表的基本思想是通过将数据的键值对映射到一个数组的索引位置上来提高数据查找的效率。具体流程如下：</p><ul><li><p><strong>哈希函数</strong>： HashMap 使用哈希函数将键（key）映射到数组的索引位置。哈希函数的目的是通过计算一个值，将不同的键映射到哈希表中的位置。</p></li><li><p><strong>数组</strong>： 哈希表内部使用一个数组来存储数据。数组中的每个元素存储一个链表（或者在 Java 8 后是</p></li></ul>',7)),e(t,{to:"/algorithm/0_base_4_tree#红黑树-balanced-binary-search-tree-bbst"},{default:p(()=>n[0]||(n[0]=[a("红黑树")])),_:1}),n[26]||(n[26]=a("），用于处理哈希冲突。")),n[27]||(n[27]=s("h3",{id:"_2、哈希冲突",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#_2、哈希冲突"},[s("span",null,"2、哈希冲突")])],-1)),n[28]||(n[28]=s("p",null,"由于哈希函数不可能做到完全唯一的映射，不同的键可能会被映射到相同的索引，这种情况称为哈希冲突。HashMap 通过以下方式解决哈希冲突：",-1)),s("ul",null,[s("li",null,[s("p",null,[n[2]||(n[2]=s("strong",null,"链表法（链式哈希）",-1)),n[3]||(n[3]=a("： 在发生冲突的情况下，HashMap 会将冲突的键值对存储到一个链表中 （或者 ")),e(t,{to:"/algorithm/0_base_4_tree#红黑树-balanced-binary-search-tree-bbst"},{default:p(()=>n[1]||(n[1]=[a("红黑树")])),_:1}),n[4]||(n[4]=a("）。 当多个元素映射到同一个索引位置时，它们会形成一个链表。"))])]),s("li",null,[s("p",null,[s("strong",null,[e(t,{to:"/algorithm/0_base_4_tree#红黑树-balanced-binary-search-tree-bbst"},{default:p(()=>n[5]||(n[5]=[a("红黑树")])),_:1}),n[6]||(n[6]=a(" 法"))]),n[8]||(n[8]=a("： 在 Java 8 及以后的版本中， 如果链表的长度超过一定阈值（默认为 8），HashMap 会将链表转化为 ")),e(t,{to:"/algorithm/0_base_4_tree#红黑树-balanced-binary-search-tree-bbst"},{default:p(()=>n[7]||(n[7]=[a("红黑树")])),_:1}),n[9]||(n[9]=a("， 以提高查询效率。"))])])]),n[29]||(n[29]=l('<p><img src="'+u+'" alt="img.png"></p><h3 id="_3、扩容机制" tabindex="-1"><a class="header-anchor" href="#_3、扩容机制"><span>3、扩容机制</span></a></h3><p>当 HashMap 中的元素过多时，哈希表的负载因子（load factor）可能会达到阈值，导致哈希表的存储效率降低。默认情况下，负载因子为 0.75。 <strong>当元素个数超过 (当前容量 * 负载因子) 时，HashMap 会进行扩容（通常是原数组大小的 2 倍）</strong>。</p><p>扩容过程中，所有元素的哈希值会被重新计算，并重新放置到新的数组位置。这是因为 <strong>哈希表的大小发生变化，导致原先的索引位置不再适用</strong>。</p><h3 id="_4、时间复杂度" tabindex="-1"><a class="header-anchor" href="#_4、时间复杂度"><span>4、时间复杂度</span></a></h3><ul><li><strong>查找、插入、删除 时间复杂度</strong>：</li></ul>',6)),s("p",null,[n[11]||(n[11]=a("在理想情况下，哈希表的查找、插入和删除操作的时间复杂度为 O(1)。但是，如果发生哈希冲突，性能会退化到 O(n)（链表长度为 n 时）。 使用 ")),e(t,{to:"/algorithm/0_base_4_tree#红黑树-balanced-binary-search-tree-bbst"},{default:p(()=>n[10]||(n[10]=[a("红黑树")])),_:1}),n[12]||(n[12]=a("优化后，最坏情况下时间复杂度为 O(log n)。"))]),n[30]||(n[30]=l('<ul><li><strong>扩容操作的时间复杂度</strong>：</li></ul><p>扩容是一个相对耗时的操作，时间复杂度为 O(n)，但扩容操作是按需进行的，不是频繁发生，因此平均而言，HashMap 的操作仍然是 O(1)。</p><h2 id="二、linkedhashmap分析" tabindex="-1"><a class="header-anchor" href="#二、linkedhashmap分析"><span>二、LinkedHashMap分析</span></a></h2><h3 id="_1、类继承关系" tabindex="-1"><a class="header-anchor" href="#_1、类继承关系"><span>1、类继承关系</span></a></h3><p><code>LinkedHashMap</code> 继承自 <code>HashMap</code>，是其子类，并复用了 <code>HashMap</code> 的大部分方法。</p><p>与 <code>HashMap</code> 不同的是，<code>LinkedHashMap</code> 结合了 <strong>哈希表（HashMap）</strong> 和 <strong>双向链表（LinkedList）</strong> 的特点，不仅提供了高效的键值存储，还维护了元素的 <strong>插入顺序</strong>。</p><p>在使用 <code>Iterator</code> 遍历 <code>LinkedHashMap</code> 时，元素的顺序与插入顺序一致。</p><p>此外，<code>LinkedHashMap</code> 还支持按照 <strong>访问顺序</strong> 排序，可在构造时通过参数指定，使最近访问的元素排列在前，适用于实现 <strong>LRU（最近最少使用）缓存策略</strong>。</p><p><img src="'+d+`" alt=""></p><h3 id="_2、基本原理" tabindex="-1"><a class="header-anchor" href="#_2、基本原理"><span>2、基本原理</span></a></h3><div class="hint-container warning"><p class="hint-container-title">Todo</p><p>更加精通后完成。。。</p></div><h2 id="三、concurrenthashmap分析" tabindex="-1"><a class="header-anchor" href="#三、concurrenthashmap分析"><span>三、ConcurrentHashMap分析</span></a></h2><h3 id="_1、基本特性" tabindex="-1"><a class="header-anchor" href="#_1、基本特性"><span>1、基本特性</span></a></h3><table><thead><tr><th><strong>特性</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>线程安全</strong></td><td>采用 CAS + 自旋锁 替代 synchronized，减少锁竞争</td></tr><tr><td><strong>高并发</strong></td><td>读操作无锁，写操作局部加锁，避免全局锁的性能瓶颈</td></tr><tr><td><strong>不支持 null</strong></td><td>key 和 value 都 不能为 null，防止 NullPointerException</td></tr><tr><td><strong>比 Hashtable 性能高</strong></td><td>Hashtable 使用 synchronized 进行全表加锁，而 ConcurrentHashMap 采用 分段锁机制（JDK 1.7）和 CAS + 自旋锁（JDK 1.8）</td></tr></tbody></table><h3 id="_2、jdk-1-7-和-1-8-的区别" tabindex="-1"><a class="header-anchor" href="#_2、jdk-1-7-和-1-8-的区别"><span>2、JDK 1.7 和 1.8 的区别</span></a></h3><table><thead><tr><th><strong>版本</strong></th><th><strong>JDK 1.7</strong></th><th><strong>JDK 1.8 及以后</strong></th></tr></thead><tbody><tr><td><strong>底层数据结构</strong></td><td>Segment（分段锁） + 数组 + 链表</td><td>数组 + 链表 + 红黑树（大于 8 个元素）</td></tr><tr><td><strong>加锁方式</strong></td><td>分段锁（Segment 继承 ReentrantLock）</td><td>CAS + 自旋锁 + synchronized（局部）</td></tr><tr><td><strong>并发控制</strong></td><td>多个 Segment 互不影响</td><td>CAS 方式优化，减少锁竞争</td></tr><tr><td><strong>写入性能</strong></td><td>分段锁，性能较好</td><td>CAS + 局部锁，性能更高</td></tr><tr><td><strong>扩容机制</strong></td><td>Segment 级别扩容</td><td>无锁扩容，支持并发扩容</td></tr></tbody></table><div class="hint-container warning"><p class="hint-container-title">Todo</p><p>更加精通后完成。。。</p></div><h2 id="四、concurrenthashmap-为什么放弃分段锁" tabindex="-1"><a class="header-anchor" href="#四、concurrenthashmap-为什么放弃分段锁"><span>四、ConcurrentHashMap 为什么放弃分段锁？</span></a></h2><h3 id="_1、jdk-1-7-前分段锁的弊端" tabindex="-1"><a class="header-anchor" href="#_1、jdk-1-7-前分段锁的弊端"><span>1、JDK 1.7 前分段锁的弊端</span></a></h3><p>在 JDK 1.7 之前，<code>ConcurrentHashMap</code> 使用 <strong>分段锁（Segment）</strong>，每个 <code>Segment</code> 管理独立的 <code>HashEntry[]</code>。但存在以下问题：</p><ul><li><p><strong>扩容性能差</strong>：扩容时需要对整个 <code>Segment</code> 加锁，影响并发。</p></li><li><p><strong>内存浪费</strong>：预先分配多个 <code>Segment</code>，即使不使用也占用内存。</p></li><li><p><strong>代码复杂</strong>：锁管理复杂，且 <code>put()</code> 需要两次 <code>hash</code> 计算，降低性能。</p></li></ul><h3 id="_2、jdk-1-8-后的新方案" tabindex="-1"><a class="header-anchor" href="#_2、jdk-1-8-后的新方案"><span>2、JDK 1.8 后的新方案</span></a></h3><p>JDK 1.8 放弃了 <code>Segment</code>，改用 <strong>数组 + 链表 + 红黑树</strong> 结构，结合 <strong>CAS</strong> 和 <strong>synchronized</strong> 局部加锁，提升并发性能。</p><ul><li><strong>CAS 无锁优化</strong>：避免锁竞争，提高吞吐量。</li></ul><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">casTabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>synchronized 局部加锁</strong>：只锁定当前桶位，减少锁竞争。</li></ul><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">synchronized</span> <span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token function">putValUnderLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>红黑树优化</strong>：当链表长度超过 8，转为红黑树，查询效率提高。</li></ul><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">&gt;=</span> <span class="token constant">TREEIFY_THRESHOLD</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>无锁扩容</strong>：多个线程并行迁移数据，提升扩容效率。</li></ul><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">if</span> <span class="token punctuation">(</span>sizeCtl <span class="token operator">&lt;</span> table<span class="token punctuation">.</span>length <span class="token operator">*</span> <span class="token number">0.75</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token function">transferNodes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3、两句话总结" tabindex="-1"><a class="header-anchor" href="#_3、两句话总结"><span>3、两句话总结</span></a></h3><ul><li><p>JDK 1.7 分段锁的性能差、空间浪费和复杂性问题。</p></li><li><p>JDK 1.8 改用 CAS、synchronized 和红黑树，提升了并发性能和查询效率，支持无锁扩容。</p></li></ul><blockquote><p><strong>提示</strong>：JDK 1.8 的 <code>ConcurrentHashMap</code> 在高并发下表现更优，避免了分段锁带来的性能瓶颈。</p></blockquote><h2 id="四、hashmap、linkedhashmap、concurrenthashmap对比" tabindex="-1"><a class="header-anchor" href="#四、hashmap、linkedhashmap、concurrenthashmap对比"><span>四、HashMap、LinkedHashMap、ConcurrentHashMap对比</span></a></h2><table><thead><tr><th><strong>对比项</strong></th><th><strong>HashMap</strong></th><th><strong>LinkedHashMap</strong></th><th><strong>ConcurrentHashMap</strong></th></tr></thead><tbody><tr><td><strong>底层数据结构</strong></td><td>哈希表（数组 + 链表/红黑树）</td><td>哈希表 + 双向链表</td><td>哈希表（分段锁、CAS 机制）</td></tr><tr><td><strong>key 是否有序</strong></td><td>❌ 无序</td><td>✅ 按插入顺序排序</td><td>❌ 无序</td></tr><tr><td><strong>时间复杂度</strong></td><td>O(1) 平均，O(n) 最坏</td><td>O(1) 平均，O(n) 最坏</td><td>O(1) 平均，O(n) 最坏</td></tr><tr><td><strong>是否允许 null key</strong></td><td>✅ 允许</td><td>✅ 允许</td><td>❌ 不允许</td></tr><tr><td><strong>是否允许 null value</strong></td><td>✅ 允许</td><td>✅ 允许</td><td>❌ 不允许</td></tr><tr><td><strong>线程安全</strong></td><td>❌ 非线程安全</td><td>❌ 非线程安全</td><td>✅ 线程安全</td></tr><tr><td><strong>适用场景</strong></td><td>快速查找、无序存储、大量数据</td><td>需要按插入顺序遍历的场景</td><td>并发环境下的高效哈希映射</td></tr><tr><td><strong>主要应用</strong></td><td>缓存、映射查找、对象存储</td><td>LRU 缓存、访问顺序存储</td><td>高并发场景，如缓存、线程池</td></tr></tbody></table><h2 id="三、treemap分析" tabindex="-1"><a class="header-anchor" href="#三、treemap分析"><span>三、TreeMap分析</span></a></h2><h3 id="_1、源码分析" tabindex="-1"><a class="header-anchor" href="#_1、源码分析"><span>1、源码分析</span></a></h3><ul><li>类关联图如下所示：</li></ul><p><img src="`+k+'" alt="image.png"></p><ul><li>TreeMap 的核心特点</li></ul>',41)),s("table",null,[n[21]||(n[21]=s("thead",null,[s("tr",null,[s("th",null,"特性"),s("th",null,"说明")])],-1)),s("tbody",null,[s("tr",null,[n[15]||(n[15]=s("td",null,"底层实现",-1)),s("td",null,[e(t,{to:"/algorithm/0_base_4_tree#红黑树-balanced-binary-search-tree-bbst"},{default:p(()=>n[13]||(n[13]=[a("红黑树")])),_:1}),n[14]||(n[14]=a("（Red-Black Tree），是一种自平衡二叉搜索树（BST）"))])]),n[16]||(n[16]=s("tr",null,[s("td",null,"排序方式"),s("td",null,"默认按 key 的 自然顺序（Comparable） 排序，也可以传入 自定义 Comparator")],-1)),n[17]||(n[17]=s("tr",null,[s("td",null,"时间复杂度"),s("td",null,"O(log n)（增、删、查）")],-1)),n[18]||(n[18]=s("tr",null,[s("td",null,"是否允许 null key"),s("td",null,"❌ 不允许 null key（会抛 NullPointerException）")],-1)),n[19]||(n[19]=s("tr",null,[s("td",null,"是否允许 null value"),s("td",null,"✅ 允许 null value")],-1)),n[20]||(n[20]=s("tr",null,[s("td",null,"是否线程安全"),s("td",null,"❌ 非线程安全（需要 Collections.synchronizedMap() 保护）")],-1))])]),n[31]||(n[31]=l(`<div class="hint-container important"><p class="hint-container-title">使用途径</p><p>适用于需要 &quot;<strong>自动排序</strong>&quot; 和 &quot;<strong>范围查询</strong>&quot; 的场景。</p></div><p>1、适用场景：数据存储时要求按照 key 进行排序，方便后续查询和展示</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token class-name">TreeMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> productMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">productMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">102</span><span class="token punctuation">,</span> <span class="token string">&quot;iPhone&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">productMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">101</span><span class="token punctuation">,</span> <span class="token string">&quot;Samsung&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">productMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">103</span><span class="token punctuation">,</span> <span class="token string">&quot;Huawei&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// 遍历时 key 是按顺序排序的（101, 102, 103）</span></span>
<span class="line"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> entry <span class="token operator">:</span> productMap<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot; -&gt; &quot;</span> <span class="token operator">+</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2、需要 &quot;范围查询&quot; 或 &quot;区间搜索&quot;</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token class-name">TreeMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> transactionMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">transactionMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">1707052800000L</span><span class="token punctuation">,</span> <span class="token string">&quot;订单 A&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 2024-02-05 00:00:00</span></span>
<span class="line">transactionMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">1707139200000L</span><span class="token punctuation">,</span> <span class="token string">&quot;订单 B&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 2024-02-06 00:00:00</span></span>
<span class="line">transactionMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">1707225600000L</span><span class="token punctuation">,</span> <span class="token string">&quot;订单 C&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 2024-02-07 00:00:00</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// 获取 2 月 5 日到 2 月 6 日之间的交易</span></span>
<span class="line"><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> transactionMap<span class="token punctuation">.</span><span class="token function">subMap</span><span class="token punctuation">(</span><span class="token number">1707052800000L</span><span class="token punctuation">,</span> <span class="token number">1707139200000L</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2、相关类对比" tabindex="-1"><a class="header-anchor" href="#_2、相关类对比"><span>2、相关类对比</span></a></h3><table><thead><tr><th><strong>对比项</strong></th><th><strong>TreeMap</strong></th><th><strong>ConcurrentSkipListMap</strong></th></tr></thead><tbody><tr><td><strong>底层数据结构</strong></td><td>红黑树（Red-Black Tree）</td><td>跳表（Skip List）</td></tr><tr><td><strong>key 是否有序</strong></td><td>✅ 有序（按 key 排序）</td><td>✅ 有序（按 key 排序）</td></tr><tr><td><strong>时间复杂度</strong></td><td>O(log n)</td><td>O(log n)</td></tr><tr><td><strong>是否允许 null key</strong></td><td>❌ 不允许</td><td>❌ 不允许</td></tr><tr><td><strong>是否允许 null value</strong></td><td>✅ 允许</td><td>✅ 允许</td></tr><tr><td><strong>线程安全</strong></td><td>❌ 非线程安全</td><td>✅ 线程安全</td></tr><tr><td><strong>适用场景</strong></td><td>需要排序、范围查询、导航结构</td><td>并发环境下的有序映射</td></tr><tr><td><strong>主要应用</strong></td><td>排名、日志存储、区间查找</td><td>线程安全的排序映射结构</td></tr></tbody></table><h2 id="四、hashmap和hashtable对比" tabindex="-1"><a class="header-anchor" href="#四、hashmap和hashtable对比"><span>四、HashMap和HashTable对比</span></a></h2><h3 id="_1、经典对比" tabindex="-1"><a class="header-anchor" href="#_1、经典对比"><span>1、经典对比</span></a></h3><table><thead><tr><th>对比项</th><th>HashMap</th><th>Hashtable</th></tr></thead><tbody><tr><td><strong>线程安全</strong></td><td>❌ 非线程安全</td><td>✅ 线程安全（方法加锁 synchronized）</td></tr><tr><td><strong>性能</strong></td><td>🚀 性能更高（无锁）</td><td>🐌 性能较低（加锁导致开销大）</td></tr><tr><td><strong>是否允许 null</strong></td><td>✅ null key/value 允许</td><td>❌ null key/value 不允许</td></tr><tr><td><strong>数据结构</strong></td><td>JDK 1.8+: 数组 + 链表/红黑树</td><td>数组 + 链表</td></tr><tr><td><strong>默认初始容量</strong></td><td>16</td><td>11</td></tr><tr><td><strong>扩容方式</strong></td><td>容量翻倍（2^n 结构优化）</td><td>容量翻倍 + 1</td></tr><tr><td><strong>遍历方式</strong></td><td>迭代器 Iterator（fail-fast 机制）</td><td>Enumeration（旧版方式）</td></tr><tr><td><strong>适用场景</strong></td><td>适用于 单线程、高性能场景</td><td>适用于 历史遗留代码、并发场景（已被淘汰）</td></tr></tbody></table><h3 id="_2、推荐-concurrenthashmap" tabindex="-1"><a class="header-anchor" href="#_2、推荐-concurrenthashmap"><span>2、推荐 ConcurrentHashMap</span></a></h3><div class="hint-container tip"><p class="hint-container-title">Tips</p><p>✅ 用 HashMap</p><ul><li>大多数场景 推荐使用 HashMap，只在单线程环境下使用。</li></ul><p>✅ 用 ConcurrentHashMap（代替 Hashtable）</p><ul><li>如果需要线程安全，<strong>请用 ConcurrentHashMap，不要用 Hashtable！</strong></li><li>ConcurrentHashMap 在 <strong>高并发 场景下比 Hashtable 性能更优（局部加锁，甚至无锁）</strong>。</li></ul></div><h2 id="五、线程的创建-thread-vs-runnable" tabindex="-1"><a class="header-anchor" href="#五、线程的创建-thread-vs-runnable"><span>五、线程的创建（Thread vs Runnable）</span></a></h2><h3 id="_1、继承-thread-类" tabindex="-1"><a class="header-anchor" href="#_1、继承-thread-类"><span>1、继承 Thread 类</span></a></h3><p>这种方法需要创建一个自定义的线程类，继承 Thread 类，并重写 run() 方法。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token annotation punctuation">@Override</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;: Hello from thread!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token class-name">MyThread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token comment">// 启动线程</span></span>
<span class="line">        thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>优点：简单直观，适合只有一个任务的情况。</p></li><li><p>缺点：如果需要继承其他类，无法再继承 Thread 类（Java 是单继承）。</p></li></ul><h3 id="_2、实现-runnable-接口" tabindex="-1"><a class="header-anchor" href="#_2、实现-runnable-接口"><span>2、实现 Runnable 接口</span></a></h3><p>这种方法更灵活，创建一个实现 Runnable 接口的类，并将其作为参数传递给 Thread 构造函数。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">class</span> <span class="token class-name">MyRunnable</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token annotation punctuation">@Override</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;: Hello from Runnable!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token class-name">MyRunnable</span> task <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyRunnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 将任务传递给线程</span></span>
<span class="line">        thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 启动线程</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>优点：允许实现多个接口，提供更多的灵活性和可扩展性。</p></li><li><p>缺点：比继承 Thread 类稍微复杂一些，但通常更加推荐。</p></li></ul><h2 id="六、volatile-关键字" tabindex="-1"><a class="header-anchor" href="#六、volatile-关键字"><span>六、volatile 关键字</span></a></h2><h3 id="_1、线程可见性机制" tabindex="-1"><a class="header-anchor" href="#_1、线程可见性机制"><span>1、线程可见性机制</span></a></h3><h4 id="内存模型图解" tabindex="-1"><a class="header-anchor" href="#内存模型图解"><span><strong>内存模型图解</strong></span></a></h4><p><img src="`+h+'" alt="volatile.png"></p><h4 id="核心特性" tabindex="-1"><a class="header-anchor" href="#核心特性"><span><strong>核心特性</strong></span></a></h4><ul><li><p><strong>即时刷新</strong>：当线程修改volatile变量时，新值<strong>立即写回主内存</strong></p></li><li><p><strong>读取穿透</strong>：其他线程读取时<strong>绕过工作内存</strong>，直接读取主内存最新值</p></li><li><p><strong>适用场景</strong>：状态标志位（如<code>boolean running</code>）、一次性安全发布</p></li></ul><blockquote><p>⚠️ 注意：<code>count++</code>这类复合操作仍需配合<code>synchronized</code>或<code>AtomicXXX</code></p></blockquote><h3 id="_2、禁止指令重排原理" tabindex="-1"><a class="header-anchor" href="#_2、禁止指令重排原理"><span>2、禁止指令重排原理</span></a></h3><h4 id="内存屏障示意图" tabindex="-1"><a class="header-anchor" href="#内存屏障示意图"><span><strong>内存屏障示意图</strong></span></a></h4><p><img src="'+m+`" alt="command_reformat.png"></p><h4 id="happens-before规则" tabindex="-1"><a class="header-anchor" href="#happens-before规则"><span><strong>happens-before规则</strong></span></a></h4><ol><li><p><strong>写屏障</strong>：确保volatile写之前的操作不会重排到写之后</p></li><li><p><strong>读屏障</strong>：防止volatile读之后的操作重排到读之前</p></li><li><p><strong>传递性</strong>：线程A写volatile变量 → 线程B读该变量 → 线程B能看到A的所有写操作</p></li></ol><h3 id="_3、双重检查锁案例" tabindex="-1"><a class="header-anchor" href="#_3、双重检查锁案例"><span>3、双重检查锁案例</span></a></h3><h4 id="正确实现代码" tabindex="-1"><a class="header-anchor" href="#正确实现代码"><span>正确实现代码</span></a></h4><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> <span class="token class-name">Singleton</span> instance<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">      <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token comment">// volatile保证以下操作不重排：</span></span>
<span class="line">        <span class="token comment">// 1. memory = allocate() 分配空间</span></span>
<span class="line">        <span class="token comment">// 2. init(memory) 初始化对象 ← StoreStore屏障在此</span></span>
<span class="line">        <span class="token comment">// 3. instance = memory 设置引用 ← StoreLoad屏障在此</span></span>
<span class="line">        instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">      <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line">  <span class="token keyword">return</span> instance<span class="token punctuation">;</span> <span class="token comment">// LoadLoad屏障保证读到最新值</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="对象创建过程图解" tabindex="-1"><a class="header-anchor" href="#对象创建过程图解"><span><strong>对象创建过程图解</strong></span></a></h4><p><img src="`+v+`" alt="singleton_double_check.png"></p><h4 id="关键作用" tabindex="-1"><a class="header-anchor" href="#关键作用"><span><strong>关键作用</strong></span></a></h4><ul><li><p>阻止<code>instance = new Singleton()</code>被重排为「先赋值后初始化」</p></li><li><p>保证其他线程拿到的是<strong>完全初始化的对象</strong></p></li></ul><h3 id="_4、对比总结表" tabindex="-1"><a class="header-anchor" href="#_4、对比总结表"><span>4、对比总结表</span></a></h3><table><thead><tr><th>特性</th><th>volatile</th><th>synchronized</th><th>AtomicXXX</th></tr></thead><tbody><tr><td>可见性</td><td>✔</td><td>✔</td><td>✔</td></tr><tr><td>原子性</td><td>✖</td><td>✔</td><td>✔</td></tr><tr><td>禁止重排</td><td>✔</td><td>✔</td><td>✖</td></tr><tr><td>性能成本</td><td>低</td><td>高</td><td>中</td></tr></tbody></table><h2 id="七、线程的等待与唤醒机制" tabindex="-1"><a class="header-anchor" href="#七、线程的等待与唤醒机制"><span>七、线程的等待与唤醒机制</span></a></h2><p>在多线程编程中，线程的等待与唤醒是实现线程间协作、资源同步的重要手段。Java 中提供了多种机制来实现线程的阻塞与唤醒， 包括基于 <code>Object</code>、<code>Thread</code>、<code>Lock</code> 以及 <code>LockSupport</code> 的方式。</p><h3 id="_1、object的wait-notify-notifyall" tabindex="-1"><a class="header-anchor" href="#_1、object的wait-notify-notifyall"><span>1、Object的wait() / notify() / notifyAll()</span></a></h3><ul><li><p>属于基础的线程通信方式，使用的是对象监视器（Monitor）。</p></li><li><p>只能在 <code>synchronized</code> 块或方法内部调用，否则会抛出 <code>IllegalMonitorStateException</code>。</p></li><li><p>方法说明：</p><ul><li><p><code>wait()</code>：当前线程等待并释放锁，进入对象的等待队列。</p></li><li><p><code>notify()</code>：唤醒一个正在等待该对象锁的线程（具体哪个由 JVM 决定）。</p></li><li><p><code>notifyAll()</code>：唤醒所有等待该对象锁的线程。</p></li></ul></li></ul><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">synchronized</span> <span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>condition<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        lock<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    <span class="token comment">// do something</span></span>
<span class="line">    lock<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2、thread-sleep" tabindex="-1"><a class="header-anchor" href="#_2、thread-sleep"><span>2、Thread.sleep()</span></a></h3><ul><li><p>使当前线程进入“睡眠状态”，在指定时间内不参与 CPU 调度。</p></li><li><p>与锁无关，不释放任何对象锁。</p></li><li><p>常用于限流、轮询等待等场景。</p></li></ul><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 休眠1秒</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="_3、lock的condition-await-signal-signalall" tabindex="-1"><a class="header-anchor" href="#_3、lock的condition-await-signal-signalall"><span>3、Lock的Condition.await() / signal() / signalAll()</span></a></h3><ul><li><p>与 <code>ReentrantLock</code> 配合使用，功能类似 <code>wait/notify</code>，但更灵活。</p></li><li><p>一个 <code>Lock</code> 可以创建多个 <code>Condition</code>，每个条件变量维护独立的等待队列。</p></li></ul><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token class-name">Lock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">Condition</span> condition <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">try</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>conditionSatisfied<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        condition<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 等待</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    <span class="token comment">// 条件满足后执行逻辑</span></span>
<span class="line">    condition<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 唤醒一个等待线程</span></span>
<span class="line"><span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span></span>
<span class="line">    lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_4、locksupport-park-unpark" tabindex="-1"><a class="header-anchor" href="#_4、locksupport-park-unpark"><span>4、LockSupport.park() / unpark()</span></a></h3><ul><li><p>更底层的线程阻塞与唤醒工具，广泛应用于并发类库（如 AQS）。</p></li><li><p>不依赖锁机制，线程可随时 <code>park()</code> 暂停自己，另一个线程通过 <code>unpark()</code> 唤醒。</p></li><li><p>支持先 <code>unpark()</code> 后 <code>park()</code> 的调用顺序，不会丢失信号。</p></li></ul><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 阻塞当前线程</span></span>
<span class="line"><span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>thread<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 唤醒指定线程</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_5、小结对比" tabindex="-1"><a class="header-anchor" href="#_5、小结对比"><span>5、小结对比</span></a></h3><table><thead><tr><th>机制</th><th>是否释放锁</th><th>是否依赖锁</th><th>唤醒粒度</th><th>应用场景</th></tr></thead><tbody><tr><td><code>wait/notify</code></td><td>是</td><td>是（synchronized）</td><td>不可控（JVM决定）</td><td>线程协作（经典用法）</td></tr><tr><td><code>sleep</code></td><td>否</td><td>否</td><td>无需唤醒</td><td>定时等待</td></tr><tr><td><code>Condition</code></td><td>是</td><td>是（Lock）</td><td>可控（条件变量）</td><td>精细控制并发</td></tr><tr><td><code>LockSupport</code></td><td>否</td><td>否</td><td>精确（线程级）</td><td>高级并发工具实现</td></tr></tbody></table><h2 id="八、线程池基础-executors" tabindex="-1"><a class="header-anchor" href="#八、线程池基础-executors"><span>八、线程池基础（Executors）</span></a></h2><h3 id="_1、executors工具类" tabindex="-1"><a class="header-anchor" href="#_1、executors工具类"><span>1、Executors工具类</span></a></h3><p><code>Executors</code> 是 Java 中用于管理线程池的一个工具类，它是 <code>java.util.concurrent</code> 包的一部分。通过 <code>Executors</code>， 我们可以轻松地创建和管理线程池，避免手动管理线程的创建和销毁，提高程序的性能和可维护性。</p><h3 id="_2、-executors-的创建方式" tabindex="-1"><a class="header-anchor" href="#_2、-executors-的创建方式"><span>2、 <code>Executors</code> 的创建方式</span></a></h3><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token comment">//创建一个固定大小的线程池，该线程池可以容纳固定数量的线程。它适用于负载较为稳定的场景，线程数固定。</span></span>
<span class="line"><span class="token class-name">ExecutorService</span> executor <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">//创建一个可缓存的线程池。该线程池会根据需要创建新线程，如果某个线程长时间没有被使用，它会被回收。</span></span>
<span class="line"><span class="token class-name">ExecutorService</span> executor <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">//创建一个单线程的线程池，所有任务会按照提交的顺序依次执行。</span></span>
<span class="line"><span class="token class-name">ExecutorService</span> executor <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">//创建一个定时任务线程池，支持任务的延迟执行和定期执行。</span></span>
<span class="line"><span class="token class-name">ScheduledExecutorService</span> executor <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newScheduledThreadPool</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">//创建一个工作窃取线程池，线程池会自动调整线程的数量，适用于有多个任务需要并发执行的场景。</span></span>
<span class="line"><span class="token class-name">ExecutorService</span> executor <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newWorkStealingPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3、-invokeall-和-invokeany" tabindex="-1"><a class="header-anchor" href="#_3、-invokeall-和-invokeany"><span>3、 <code>invokeAll()</code> 和 <code>invokeAny()</code></span></a></h3><p>这两个方法用于执行任务：</p><ul><li><p><strong><code>invokeAll()</code></strong>：将一组任务提交给线程池并等待所有任务执行完成。返回一个 <code>List&lt;Future&gt;</code>，表示每个任务的执行结果。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Callable</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> tasks <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">tasks<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">tasks<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Future</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> results <span class="token operator">=</span> executor<span class="token punctuation">.</span><span class="token function">invokeAll</span><span class="token punctuation">(</span>tasks<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong><code>invokeAny()</code></strong>：将一组任务提交给线程池，并等待其中任意一个任务完成。返回第一个完成任务的结果。</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token class-name">Integer</span> result <span class="token operator">=</span> executor<span class="token punctuation">.</span><span class="token function">invokeAny</span><span class="token punctuation">(</span>tasks<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li></ul><h3 id="_4、使用-future-和-callable" tabindex="-1"><a class="header-anchor" href="#_4、使用-future-和-callable"><span>4、使用 <code>Future</code> 和 <code>Callable</code></span></a></h3><p>当需要获取任务执行结果时，通常会使用 <code>Future</code> 和 <code>Callable</code>：</p><ul><li><strong><code>Future</code></strong>：表示一个异步计算的结果，可以通过 <code>get()</code> 方法获取任务执行结果。</li><li><strong><code>Callable</code></strong>：类似于 <code>Runnable</code>，但是可以返回结果，并且可以抛出异常。</li></ul><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token class-name">ExecutorService</span> executor <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> task <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// 执行任务</span></span>
<span class="line">    <span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> future <span class="token operator">=</span> executor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">Integer</span> result <span class="token operator">=</span> future<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取任务执行结果</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_5、executors-总结" tabindex="-1"><a class="header-anchor" href="#_5、executors-总结"><span>5、Executors 总结</span></a></h3><p><code>Executors</code> 类提供了多种类型的线程池，可以根据任务的需求选择不同类型的线程池。合理使用线程池可以提高并发程序的性能， 并且避免了手动管理线程的复杂性，避免了线程创建和销毁的开销。</p><h3 id="_6、为何不建议-executors" tabindex="-1"><a class="header-anchor" href="#_6、为何不建议-executors"><span>6、为何不建议 Executors？</span></a></h3><p><strong>Executors</strong> 返回的线程池对象的弊端如下:</p><ul><li><p><strong>FixedThreadPool</strong> 和 <strong>SingleThreadPool</strong>: 允许的请求队列（<strong>LinkedBlockingQueue</strong>）长度为 <strong>Integer.MAX VALUE</strong>，可能会堆积大量的请求，从而导致 OOM。</p></li><li><p><strong>CachedThreadPool</strong>: 允许的创建线程数量为 <strong>LinkedBlockingQueue</strong>，可能会创建大量的线程，从而导致 OOM。</p></li></ul>`,75)),s("p",null,[n[23]||(n[23]=a("综上，为了手动控制线程池，建议自己使用 ")),e(t,{to:"/concurrent/1_threadpool"},{default:p(()=>n[22]||(n[22]=[a("ThreadPoolExecutor")])),_:1}),n[24]||(n[24]=a(" 来创建线程池"))]),n[32]||(n[32]=l('<h2 id="九、threadlocal" tabindex="-1"><a class="header-anchor" href="#九、threadlocal"><span>九、ThreadLocal</span></a></h2><h3 id="_1、基础概念" tabindex="-1"><a class="header-anchor" href="#_1、基础概念"><span>1、基础概念</span></a></h3><p><code>ThreadLocal</code> 是 Java 中的一个类，用于为每个线程提供一个 <strong>独立的变量副本</strong>。每个线程都会有该变量的一个独立副本，因此一个线程的修改不会影响其他线程的副本。</p><h4 id="特点" tabindex="-1"><a class="header-anchor" href="#特点"><span><strong>特点：</strong></span></a></h4><ul><li><p>每个线程都会持有自己独立的 <strong>ThreadLocal 变量副本</strong>。</p></li><li><p>线程之间的变量是隔离的，不会相互影响。</p></li><li><p>通常用于在多线程环境中保存线程级别的局部变量，例如数据库连接、用户会话等。</p></li><li><p>线程结束时，相关资源（如内存）可以被清理。</p></li></ul><h3 id="_2、底层原理" tabindex="-1"><a class="header-anchor" href="#_2、底层原理"><span>2、底层原理</span></a></h3><p><img src="'+g+'" alt="img_5.png"></p><h3 id="_3、内部结构" tabindex="-1"><a class="header-anchor" href="#_3、内部结构"><span>3、内部结构</span></a></h3><p><img src="'+b+`" alt="img_5.png"></p><h3 id="_4、示例代码" tabindex="-1"><a class="header-anchor" href="#_4、示例代码"><span>4、示例代码</span></a></h3><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocalExample</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> threadLocalValue <span class="token operator">=</span> <span class="token class-name">ThreadLocal</span><span class="token punctuation">.</span><span class="token function">withInitial</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token comment">// 模拟多线程环境</span></span>
<span class="line">        <span class="token class-name">Runnable</span> task <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">            <span class="token keyword">int</span> value <span class="token operator">=</span> threadLocalValue<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot; initial value: &quot;</span> <span class="token operator">+</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">            threadLocalValue<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>value <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 修改该线程的副本</span></span>
<span class="line">            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot; modified value: &quot;</span> <span class="token operator">+</span> threadLocalValue<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">        <span class="token comment">// 启动两个线程</span></span>
<span class="line">        <span class="token class-name">Thread</span> t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token class-name">Thread</span> t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>输出：</strong></p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">Thread-0 initial value: 0</span>
<span class="line">Thread-1 initial value: 0</span>
<span class="line">Thread-0 modified value: 1</span>
<span class="line">Thread-1 modified value: 1</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>线程 <code>Thread-0</code> 和 <code>Thread-1</code> 拥有各自独立的 <code>ThreadLocal</code> 变量副本，互不干扰。</li></ul><h3 id="_5、适用场景" tabindex="-1"><a class="header-anchor" href="#_5、适用场景"><span>5、适用场景</span></a></h3><ul><li><p><strong>线程局部变量</strong>：例如存储每个线程的连接信息、日志标识符等。</p></li><li><p><strong>避免竞争条件</strong>：避免多个线程共享变量时引发的线程安全问题。</p></li></ul><h2 id="十、transmittablethreadlocal" tabindex="-1"><a class="header-anchor" href="#十、transmittablethreadlocal"><span>十、TransmittableThreadLocal</span></a></h2><h3 id="_1、基础概念-1" tabindex="-1"><a class="header-anchor" href="#_1、基础概念-1"><span>1、基础概念</span></a></h3><p><code>TransmittableThreadLocal</code> 是一种基于 <code>ThreadLocal</code> 的增强版本，通常是第三方库（如 <code>Alibaba</code> 的 <strong>Arthas</strong> 库）提供的，它的主要 功能是 <strong>支持跨线程传递 ThreadLocal 的值</strong>，特别是在异步任务或线程池中，<code>ThreadLocal</code> 的值会被丢失，因为线程池的线程是复用的。</p><ul><li><p>与 <code>ThreadLocal</code> 不同，<code>TransmittableThreadLocal</code> 支持 <strong>跨线程传递变量</strong>，即使是线程池或异步执行的情况，也可以传递变量的值。</p></li><li><p>适用于线程池中的任务或异步操作，它可以 <strong>继承父线程中的 <code>ThreadLocal</code> 值</strong>，即使线程被池复用，值也能正确传递到子线程。</p></li><li><p>线程池的复用特性会导致传统 <code>ThreadLocal</code> 的值丢失，但 <code>TransmittableThreadLocal</code> 解决了这一问题，能够传递这些值。</p></li></ul><h3 id="_2、示例代码" tabindex="-1"><a class="header-anchor" href="#_2、示例代码"><span>2、示例代码</span></a></h3><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>alibaba<span class="token punctuation">.</span>ttl<span class="token punctuation">.</span></span><span class="token class-name">TransmittableThreadLocal</span></span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TransmittableThreadLocalExample</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">TransmittableThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> transmittableThreadLocalValue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TransmittableThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        transmittableThreadLocalValue<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 设置主线程中的值</span></span>
<span class="line"></span>
<span class="line">        <span class="token comment">// 模拟一个线程池中的任务</span></span>
<span class="line">        <span class="token class-name">Runnable</span> task <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">            <span class="token class-name">Integer</span> value <span class="token operator">=</span> transmittableThreadLocalValue<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot; value: &quot;</span> <span class="token operator">+</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 子线程继承了主线程的值</span></span>
<span class="line">        <span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">        <span class="token comment">// 启动线程池任务</span></span>
<span class="line">        <span class="token class-name">Thread</span> t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token class-name">Thread</span> t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>输出：</strong></p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">Thread-0 value: 10</span>
<span class="line">Thread-1 value: 10</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>这里，<code>TransmittableThreadLocal</code> 的值（<code>10</code>）从主线程传递到子线程，即使是通过线程池执行任务。</li></ul><h3 id="_3、适用场景" tabindex="-1"><a class="header-anchor" href="#_3、适用场景"><span>3、适用场景</span></a></h3><ul><li><p><strong>跨线程传递</strong>：当需要在异步执行（例如线程池）或任务传递中保持 <code>ThreadLocal</code> 值时。</p></li><li><p><strong>增强的线程安全</strong>：特别适用于需要在并行任务中传递父线程上下文的场景。</p></li></ul><h3 id="_4、对比-threadlocal" tabindex="-1"><a class="header-anchor" href="#_4、对比-threadlocal"><span>4、对比 Threadlocal</span></a></h3><table><thead><tr><th>特性</th><th><strong>ThreadLocal</strong></th><th><strong>TransmittableThreadLocal</strong></th></tr></thead><tbody><tr><td><strong>线程隔离</strong></td><td>每个线程有自己的副本，线程之间互不干扰</td><td>支持跨线程传递，适合线程池和异步任务</td></tr><tr><td><strong>跨线程传递</strong></td><td>不支持</td><td>支持跨线程传递（尤其是在线程池中）</td></tr><tr><td><strong>适用场景</strong></td><td>线程局部变量，避免线程之间共享变量引发的问题</td><td>跨线程任务传递，线程池和异步任务的上下文传递</td></tr><tr><td><strong>库</strong></td><td>Java 标准库</td><td>通常是第三方库（如 Alibaba）提供的扩展</td></tr></tbody></table><ul><li><p><strong><code>ThreadLocal</code></strong> 更适合 <strong>单线程内部的线程局部存储</strong>，适用于普通的多线程编程。</p></li><li><p><strong><code>TransmittableThreadLocal</code></strong> 适合于 <strong>需要传递 ThreadLocal 值的异步操作或线程池</strong>，解决了传统 <code>ThreadLocal</code> 在跨线程场景下丢失的问题。</p></li></ul>`,30))])}const T=o(f,[["render",y],["__file","1_base.html.vue"]]),w=JSON.parse('{"path":"/java/1_base.html","title":"Java 基础","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"一、Hashmap分析","slug":"一、hashmap分析","link":"#一、hashmap分析","children":[{"level":3,"title":"1、哈希表（Hash Table）","slug":"_1、哈希表-hash-table","link":"#_1、哈希表-hash-table","children":[]},{"level":3,"title":"2、哈希冲突","slug":"_2、哈希冲突","link":"#_2、哈希冲突","children":[]},{"level":3,"title":"3、扩容机制","slug":"_3、扩容机制","link":"#_3、扩容机制","children":[]},{"level":3,"title":"4、时间复杂度","slug":"_4、时间复杂度","link":"#_4、时间复杂度","children":[]}]},{"level":2,"title":"二、LinkedHashMap分析","slug":"二、linkedhashmap分析","link":"#二、linkedhashmap分析","children":[{"level":3,"title":"1、类继承关系","slug":"_1、类继承关系","link":"#_1、类继承关系","children":[]},{"level":3,"title":"2、基本原理","slug":"_2、基本原理","link":"#_2、基本原理","children":[]}]},{"level":2,"title":"三、ConcurrentHashMap分析","slug":"三、concurrenthashmap分析","link":"#三、concurrenthashmap分析","children":[{"level":3,"title":"1、基本特性","slug":"_1、基本特性","link":"#_1、基本特性","children":[]},{"level":3,"title":"2、JDK 1.7 和 1.8 的区别","slug":"_2、jdk-1-7-和-1-8-的区别","link":"#_2、jdk-1-7-和-1-8-的区别","children":[]}]},{"level":2,"title":"四、ConcurrentHashMap 为什么放弃分段锁？","slug":"四、concurrenthashmap-为什么放弃分段锁","link":"#四、concurrenthashmap-为什么放弃分段锁","children":[{"level":3,"title":"1、JDK 1.7 前分段锁的弊端","slug":"_1、jdk-1-7-前分段锁的弊端","link":"#_1、jdk-1-7-前分段锁的弊端","children":[]},{"level":3,"title":"2、JDK 1.8 后的新方案","slug":"_2、jdk-1-8-后的新方案","link":"#_2、jdk-1-8-后的新方案","children":[]},{"level":3,"title":"3、两句话总结","slug":"_3、两句话总结","link":"#_3、两句话总结","children":[]}]},{"level":2,"title":"四、HashMap、LinkedHashMap、ConcurrentHashMap对比","slug":"四、hashmap、linkedhashmap、concurrenthashmap对比","link":"#四、hashmap、linkedhashmap、concurrenthashmap对比","children":[]},{"level":2,"title":"三、TreeMap分析","slug":"三、treemap分析","link":"#三、treemap分析","children":[{"level":3,"title":"1、源码分析","slug":"_1、源码分析","link":"#_1、源码分析","children":[]},{"level":3,"title":"2、相关类对比","slug":"_2、相关类对比","link":"#_2、相关类对比","children":[]}]},{"level":2,"title":"四、HashMap和HashTable对比","slug":"四、hashmap和hashtable对比","link":"#四、hashmap和hashtable对比","children":[{"level":3,"title":"1、经典对比","slug":"_1、经典对比","link":"#_1、经典对比","children":[]},{"level":3,"title":"2、推荐 ConcurrentHashMap","slug":"_2、推荐-concurrenthashmap","link":"#_2、推荐-concurrenthashmap","children":[]}]},{"level":2,"title":"五、线程的创建（Thread vs Runnable）","slug":"五、线程的创建-thread-vs-runnable","link":"#五、线程的创建-thread-vs-runnable","children":[{"level":3,"title":"1、继承 Thread 类","slug":"_1、继承-thread-类","link":"#_1、继承-thread-类","children":[]},{"level":3,"title":"2、实现 Runnable 接口","slug":"_2、实现-runnable-接口","link":"#_2、实现-runnable-接口","children":[]}]},{"level":2,"title":"六、volatile 关键字","slug":"六、volatile-关键字","link":"#六、volatile-关键字","children":[{"level":3,"title":"1、线程可见性机制","slug":"_1、线程可见性机制","link":"#_1、线程可见性机制","children":[]},{"level":3,"title":"2、禁止指令重排原理","slug":"_2、禁止指令重排原理","link":"#_2、禁止指令重排原理","children":[]},{"level":3,"title":"3、双重检查锁案例","slug":"_3、双重检查锁案例","link":"#_3、双重检查锁案例","children":[]},{"level":3,"title":"4、对比总结表","slug":"_4、对比总结表","link":"#_4、对比总结表","children":[]}]},{"level":2,"title":"七、线程的等待与唤醒机制","slug":"七、线程的等待与唤醒机制","link":"#七、线程的等待与唤醒机制","children":[{"level":3,"title":"1、Object的wait() / notify() / notifyAll()","slug":"_1、object的wait-notify-notifyall","link":"#_1、object的wait-notify-notifyall","children":[]},{"level":3,"title":"2、Thread.sleep()","slug":"_2、thread-sleep","link":"#_2、thread-sleep","children":[]},{"level":3,"title":"3、Lock的Condition.await() / signal() / signalAll()","slug":"_3、lock的condition-await-signal-signalall","link":"#_3、lock的condition-await-signal-signalall","children":[]},{"level":3,"title":"4、LockSupport.park() / unpark()","slug":"_4、locksupport-park-unpark","link":"#_4、locksupport-park-unpark","children":[]},{"level":3,"title":"5、小结对比","slug":"_5、小结对比","link":"#_5、小结对比","children":[]}]},{"level":2,"title":"八、线程池基础（Executors）","slug":"八、线程池基础-executors","link":"#八、线程池基础-executors","children":[{"level":3,"title":"1、Executors工具类","slug":"_1、executors工具类","link":"#_1、executors工具类","children":[]},{"level":3,"title":"2、 Executors 的创建方式","slug":"_2、-executors-的创建方式","link":"#_2、-executors-的创建方式","children":[]},{"level":3,"title":"3、 invokeAll() 和 invokeAny()","slug":"_3、-invokeall-和-invokeany","link":"#_3、-invokeall-和-invokeany","children":[]},{"level":3,"title":"4、使用 Future 和 Callable","slug":"_4、使用-future-和-callable","link":"#_4、使用-future-和-callable","children":[]},{"level":3,"title":"5、Executors 总结","slug":"_5、executors-总结","link":"#_5、executors-总结","children":[]},{"level":3,"title":"6、为何不建议 Executors？","slug":"_6、为何不建议-executors","link":"#_6、为何不建议-executors","children":[]}]},{"level":2,"title":"九、ThreadLocal","slug":"九、threadlocal","link":"#九、threadlocal","children":[{"level":3,"title":"1、基础概念","slug":"_1、基础概念","link":"#_1、基础概念","children":[]},{"level":3,"title":"2、底层原理","slug":"_2、底层原理","link":"#_2、底层原理","children":[]},{"level":3,"title":"3、内部结构","slug":"_3、内部结构","link":"#_3、内部结构","children":[]},{"level":3,"title":"4、示例代码","slug":"_4、示例代码","link":"#_4、示例代码","children":[]},{"level":3,"title":"5、适用场景","slug":"_5、适用场景","link":"#_5、适用场景","children":[]}]},{"level":2,"title":"十、TransmittableThreadLocal","slug":"十、transmittablethreadlocal","link":"#十、transmittablethreadlocal","children":[{"level":3,"title":"1、基础概念","slug":"_1、基础概念-1","link":"#_1、基础概念-1","children":[]},{"level":3,"title":"2、示例代码","slug":"_2、示例代码","link":"#_2、示例代码","children":[]},{"level":3,"title":"3、适用场景","slug":"_3、适用场景","link":"#_3、适用场景","children":[]},{"level":3,"title":"4、对比 Threadlocal","slug":"_4、对比-threadlocal","link":"#_4、对比-threadlocal","children":[]}]}],"git":{"updatedTime":1745640513000,"contributors":[{"name":"Clarence","username":"Clarence","email":"1154937362@qq.com","commits":15,"url":"https://github.com/Clarence"},{"name":"hanchen","username":"hanchen","email":"1154937362@qq.com","commits":10,"url":"https://github.com/hanchen"},{"name":"hello0709","username":"hello0709","email":"1154937362@qq.com","commits":1,"url":"https://github.com/hello0709"}]},"filePathRelative":"java/1_base.md"}');export{T as comp,w as data};
