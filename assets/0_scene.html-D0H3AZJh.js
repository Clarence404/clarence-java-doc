import{_ as l,c as s,a,b as t,d as n,e as i,f as d,r as h,o}from"./app-CDu6Lb1v.js";const c={};function p(u,e){const r=h("RouteLink");return o(),s("div",null,[e[2]||(e[2]=a('<h1 id="常见的场景问题" tabindex="-1"><a class="header-anchor" href="#常见的场景问题"><span>常见的场景问题</span></a></h1><h2 id="一、分布式系统主键如何处理" tabindex="-1"><a class="header-anchor" href="#一、分布式系统主键如何处理"><span>一、分布式系统主键如何处理？</span></a></h2><h3 id="_1、节点生成-or-主键服务" tabindex="-1"><a class="header-anchor" href="#_1、节点生成-or-主键服务"><span>1、节点生成 or 主键服务？</span></a></h3><h3 id="_2、主键类型的选择" tabindex="-1"><a class="header-anchor" href="#_2、主键类型的选择"><span>2、主键类型的选择？</span></a></h3><h2 id="二、针对于过期的订单-如何处理" tabindex="-1"><a class="header-anchor" href="#二、针对于过期的订单-如何处理"><span>二、针对于过期的订单，如何处理？</span></a></h2><p><a href="https://mp.weixin.qq.com/s/aHtIW4vmrl-0rUcPI3T7ZQ" target="_blank" rel="noopener noreferrer">处理过期订单，Redis不推荐，那如何做呢？</a></p><h3 id="_1、消息队列" tabindex="-1"><a class="header-anchor" href="#_1、消息队列"><span>1、消息队列</span></a></h3><h3 id="_2、redisson-delayedqueue" tabindex="-1"><a class="header-anchor" href="#_2、redisson-delayedqueue"><span>2、Redisson DelayedQueue</span></a></h3><h3 id="_3、redis-过期监听" tabindex="-1"><a class="header-anchor" href="#_3、redis-过期监听"><span>3、Redis 过期监听</span></a></h3><h3 id="_4、rabbitmq-死信队列" tabindex="-1"><a class="header-anchor" href="#_4、rabbitmq-死信队列"><span>4、RabbitMQ 死信队列</span></a></h3><h3 id="_5、时间轮" tabindex="-1"><a class="header-anchor" href="#_5、时间轮"><span>5、时间轮</span></a></h3><h2 id="三、如何实现自动登录功能" tabindex="-1"><a class="header-anchor" href="#三、如何实现自动登录功能"><span>三、如何实现自动登录功能？</span></a></h2><p><a href="https://docs.pingcode.com/baike/2210471" target="_blank" rel="noopener noreferrer">https://docs.pingcode.com/baike/2210471</a></p><h2 id="四、对外的api安全问题如何保证" tabindex="-1"><a class="header-anchor" href="#四、对外的api安全问题如何保证"><span>四、对外的Api安全问题如何保证？</span></a></h2><p>Todo 按照自己的理解实现：</p><p><a href="https://mp.weixin.qq.com/s/kZZMQcAQh4XLF8sgsxT__g" target="_blank" rel="noopener noreferrer">Spring Cloud微服务，如何保证对外接口的安全？</a></p><h2 id="五、基于阻塞队列实现生产者和消费者模型" tabindex="-1"><a class="header-anchor" href="#五、基于阻塞队列实现生产者和消费者模型"><span>五、基于阻塞队列实现生产者和消费者模型</span></a></h2><blockquote></blockquote><p>参考地址：<a href="https://blog.csdn.net/m0_73381672/article/details/133690633" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/m0_73381672/article/details/133690633</a></p><p>核心方法代码：</p><p><a href="https://gitee.com/hello0709/clarence-java/raw/master/basic/src/main/java/com/dora/basic/juc/blockqueue/MyBlockingQueue.java" target="_blank" rel="noopener noreferrer">MyBlockingQueue</a></p><p>测试运行代码：</p><p><a href="https://gitee.com/hello0709/clarence-java/raw/master/basic/src/main/java/com/dora/basic/juc/blockqueue/Test.java" target="_blank" rel="noopener noreferrer">MyBlockingQueue.Test</a></p><h2 id="六、如何设计一个高并发系统" tabindex="-1"><a class="header-anchor" href="#六、如何设计一个高并发系统"><span>六、如何设计一个高并发系统？</span></a></h2>',24)),t("p",null,[e[1]||(e[1]=n("解答：")),i(r,{to:"/currency/4_high_concurrency_sys"},{default:d(()=>e[0]||(e[0]=[n("高并发-如何设计一个高并发系统？")])),_:1})]),e[3]||(e[3]=a(`<h2 id="七、分布式场景下是否适用-synchronized-加锁机制" tabindex="-1"><a class="header-anchor" href="#七、分布式场景下是否适用-synchronized-加锁机制"><span>七、分布式场景下是否适用 synchronized 加锁机制？</span></a></h2><p>解答：<a href="https://mp.weixin.qq.com/s/IGS_8pIc2wSKN88eMEJmSg" target="_blank" rel="noopener noreferrer">分布式场景下是否适用 synchronized 加锁机制？</a></p><h2 id="八、100-亿分库分表-如何设计" tabindex="-1"><a class="header-anchor" href="#八、100-亿分库分表-如何设计"><span>八、100 亿分库分表 如何设计？</span></a></h2><p>解答：<a href="https://mp.weixin.qq.com/s/xQtKtaLG8xRMbK-8b3Rzuw" target="_blank" rel="noopener noreferrer">携程面试：100 亿分库分表 如何设计？</a></p><h2 id="九、说说-布隆过滤器-的实战应用" tabindex="-1"><a class="header-anchor" href="#九、说说-布隆过滤器-的实战应用"><span>九、说说 布隆过滤器 的实战应用？</span></a></h2><h2 id="十、缓存数据消费模型-服务端推送-vs-客户端拉取-如何选择" tabindex="-1"><a class="header-anchor" href="#十、缓存数据消费模型-服务端推送-vs-客户端拉取-如何选择"><span>十、缓存数据消费模型：服务端推送 vs 客户端拉取，如何选择？</span></a></h2><p>这是一个<strong>经典的推送 vs 拉取</strong>场景问题。在数据做了缓存（例如 Redis、Caffeine 等）以后，如何将缓存中的数据“及时、安全、稳定”地被后台接口消耗，选用“服务端推送”还是“客户端拉取”，需要根据场景进行权衡。</p><hr><h3 id="🎯-一句话结论" tabindex="-1"><a class="header-anchor" href="#🎯-一句话结论"><span>🎯 一句话结论：</span></a></h3><blockquote><p><strong>如果数据对实时性要求高，推送更优；如果数据处理节奏不一、可容忍延迟，拉取更稳。</strong></p></blockquote><hr><h3 id="🧭-两种方式比较" tabindex="-1"><a class="header-anchor" href="#🧭-两种方式比较"><span>🧭 两种方式比较</span></a></h3><table><thead><tr><th>维度</th><th>服务端推送（Push）</th><th>客户端拉取（Pull）</th></tr></thead><tbody><tr><td><strong>实时性</strong></td><td>⭐⭐⭐⭐☆ 高</td><td>⭐⭐☆☆☆ 低（取决于轮询频率）</td></tr><tr><td><strong>系统压力可控性</strong></td><td>⭐⭐☆☆☆ 不可控，易突发</td><td>⭐⭐⭐⭐☆ 主动控制频率</td></tr><tr><td><strong>可靠性</strong></td><td>⭐⭐☆☆☆ 需额外处理失败重试</td><td>⭐⭐⭐⭐☆ 拉不到就下次再拉</td></tr><tr><td><strong>实现复杂度</strong></td><td>⭐⭐⭐⭐☆ 较高，需要连接/通道</td><td>⭐⭐☆☆☆ 简单易用</td></tr><tr><td><strong>典型方案</strong></td><td>WebSocket、SSE、MQ（间接推送）</td><td>HTTP 轮询、定时任务、批量拉取</td></tr></tbody></table><hr><h3 id="🛠️-场景建议" tabindex="-1"><a class="header-anchor" href="#🛠️-场景建议"><span>🛠️ 场景建议</span></a></h3><h4 id="✅-适合用-服务端推送-的场景" tabindex="-1"><a class="header-anchor" href="#✅-适合用-服务端推送-的场景"><span>✅ 适合用 <strong>服务端推送</strong> 的场景：</span></a></h4><ul><li>数据实时性要求高（如秒级指标、实时告警）</li><li>接收方处理能力强（不会被大量数据压垮）</li><li>已经有成熟 MQ 或推送架构（Kafka、RocketMQ、WebSocket）</li></ul><p>例如：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">- 缓存中是实时统计数据，需立刻展示到前端 → WebSocket 推送</span>
<span class="line">- 数据是任务调度触发的计算结果 → 使用 MQ 推送给消费者接口</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="✅-适合用-客户端拉取-的场景" tabindex="-1"><a class="header-anchor" href="#✅-适合用-客户端拉取-的场景"><span>✅ 适合用 <strong>客户端拉取</strong> 的场景：</span></a></h4><ul><li>消费方处理能力不稳定（可能“吃不动”）</li><li>业务允许分钟级延迟</li><li>多个消费方需要不同节奏消费（如分页）</li></ul><p>例如：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">- 缓存中是预加载的账单数据，后台服务每分钟批量拉取 → 安全且压力可控</span>
<span class="line">- 某系统状态缓存更新，但后台服务仅需每 5 秒刷新 UI → 使用拉取</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="🔁-实践中的混合方式-推荐" tabindex="-1"><a class="header-anchor" href="#🔁-实践中的混合方式-推荐"><span>🔁 实践中的混合方式（推荐）</span></a></h3><p>很多系统会结合使用两者：</p><blockquote><p><strong>Push for fast, Pull for reliable</strong> 推送用于及时通知，拉取用于兜底保障。</p></blockquote><p>比如：</p><ul><li>缓存更新后通过 MQ 推送通知后台接口</li><li>后台接口如果错过了 MQ 消息，可以每分钟轮询缓存补救</li></ul><hr><h3 id="✅-建议总结" tabindex="-1"><a class="header-anchor" href="#✅-建议总结"><span>✅ 建议总结</span></a></h3><p>如果你是：</p><ul><li><strong>缓存是主动计算出来的结果</strong> → 推荐客户端拉取，防止重复推送、资源浪费</li><li><strong>缓存是事件驱动产生的数据</strong> → 推荐服务端推送，保证及时反应</li><li><strong>稳定性比实时性更重要</strong> → 推荐拉取</li><li><strong>两者都要求</strong> → 推送通知 + 拉取校验（最佳实践）</li></ul>`,33))])}const g=l(c,[["render",p],["__file","0_scene.html.vue"]]),m=JSON.parse('{"path":"/scenario/0_scene.html","title":"常见的场景问题","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"一、分布式系统主键如何处理？","slug":"一、分布式系统主键如何处理","link":"#一、分布式系统主键如何处理","children":[{"level":3,"title":"1、节点生成 or 主键服务？","slug":"_1、节点生成-or-主键服务","link":"#_1、节点生成-or-主键服务","children":[]},{"level":3,"title":"2、主键类型的选择？","slug":"_2、主键类型的选择","link":"#_2、主键类型的选择","children":[]}]},{"level":2,"title":"二、针对于过期的订单，如何处理？","slug":"二、针对于过期的订单-如何处理","link":"#二、针对于过期的订单-如何处理","children":[{"level":3,"title":"1、消息队列","slug":"_1、消息队列","link":"#_1、消息队列","children":[]},{"level":3,"title":"2、Redisson DelayedQueue","slug":"_2、redisson-delayedqueue","link":"#_2、redisson-delayedqueue","children":[]},{"level":3,"title":"3、Redis 过期监听","slug":"_3、redis-过期监听","link":"#_3、redis-过期监听","children":[]},{"level":3,"title":"4、RabbitMQ 死信队列","slug":"_4、rabbitmq-死信队列","link":"#_4、rabbitmq-死信队列","children":[]},{"level":3,"title":"5、时间轮","slug":"_5、时间轮","link":"#_5、时间轮","children":[]}]},{"level":2,"title":"三、如何实现自动登录功能？","slug":"三、如何实现自动登录功能","link":"#三、如何实现自动登录功能","children":[]},{"level":2,"title":"四、对外的Api安全问题如何保证？","slug":"四、对外的api安全问题如何保证","link":"#四、对外的api安全问题如何保证","children":[]},{"level":2,"title":"五、基于阻塞队列实现生产者和消费者模型","slug":"五、基于阻塞队列实现生产者和消费者模型","link":"#五、基于阻塞队列实现生产者和消费者模型","children":[]},{"level":2,"title":"六、如何设计一个高并发系统？","slug":"六、如何设计一个高并发系统","link":"#六、如何设计一个高并发系统","children":[]},{"level":2,"title":"七、分布式场景下是否适用 synchronized 加锁机制？","slug":"七、分布式场景下是否适用-synchronized-加锁机制","link":"#七、分布式场景下是否适用-synchronized-加锁机制","children":[]},{"level":2,"title":"八、100 亿分库分表 如何设计？","slug":"八、100-亿分库分表-如何设计","link":"#八、100-亿分库分表-如何设计","children":[]},{"level":2,"title":"九、说说 布隆过滤器 的实战应用？","slug":"九、说说-布隆过滤器-的实战应用","link":"#九、说说-布隆过滤器-的实战应用","children":[]},{"level":2,"title":"十、缓存数据消费模型：服务端推送 vs 客户端拉取，如何选择？","slug":"十、缓存数据消费模型-服务端推送-vs-客户端拉取-如何选择","link":"#十、缓存数据消费模型-服务端推送-vs-客户端拉取-如何选择","children":[{"level":3,"title":"🎯 一句话结论：","slug":"🎯-一句话结论","link":"#🎯-一句话结论","children":[]},{"level":3,"title":"🧭 两种方式比较","slug":"🧭-两种方式比较","link":"#🧭-两种方式比较","children":[]},{"level":3,"title":"🛠️ 场景建议","slug":"🛠️-场景建议","link":"#🛠️-场景建议","children":[]},{"level":3,"title":"🔁 实践中的混合方式（推荐）","slug":"🔁-实践中的混合方式-推荐","link":"#🔁-实践中的混合方式-推荐","children":[]},{"level":3,"title":"✅ 建议总结","slug":"✅-建议总结","link":"#✅-建议总结","children":[]}]}],"git":{"updatedTime":1748269182000,"contributors":[{"name":"Clarence","username":"Clarence","email":"1154937362@qq.com","commits":1,"url":"https://github.com/Clarence"}]},"filePathRelative":"scenario/0_scene.md"}');export{g as comp,m as data};
