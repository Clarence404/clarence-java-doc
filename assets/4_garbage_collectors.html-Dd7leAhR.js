import{_ as t,c as e,a,o as i}from"./app-CXuvinNa.js";const d={};function n(r,l){return i(),e("div",null,l[0]||(l[0]=[a('<h1 id="垃圾收集器对比" tabindex="-1"><a class="header-anchor" href="#垃圾收集器对比"><span>垃圾收集器对比</span></a></h1><h2 id="serial" tabindex="-1"><a class="header-anchor" href="#serial"><span>Serial</span></a></h2><ul><li>单线程，适用于小内存客户端。</li><li>新生代：复制算法，老年代：标记-整理算法。</li><li>STW 时间较长，适合单核 CPU。</li><li>参数：-XX:+UseSerialGC</li></ul><h2 id="parnew" tabindex="-1"><a class="header-anchor" href="#parnew"><span>ParNew</span></a></h2><ul><li>多线程版 Serial，适用于配合 CMS 使用。</li><li>新生代：复制算法，多线程并行收集。</li><li>老年代仍使用 Serial Old 或 CMS。</li><li>参数：-XX:+UseParNewGC</li></ul><h2 id="parallel-scavenge-parallel-old" tabindex="-1"><a class="header-anchor" href="#parallel-scavenge-parallel-old"><span>Parallel Scavenge / Parallel Old</span></a></h2><ul><li>关注吞吐量，适合后台计算任务。</li><li>新生代：复制算法，老年代：标记-整理算法。</li><li>可配置最大停顿时间和吞吐量目标。</li><li>参数：-XX:+UseParallelGC</li></ul><h2 id="cms-已淘汰" tabindex="-1"><a class="header-anchor" href="#cms-已淘汰"><span>CMS（已淘汰）</span></a></h2><ul><li>并发标记清除，低停顿，内存碎片问题严重。</li><li>四个阶段：初始标记（STW）、并发标记、重新标记（STW）、并发清除。</li><li>JDK9 标记为废弃，JDK14 移除。</li><li>参数：-XX:+UseConcMarkSweepGC</li></ul><h2 id="g1-jdk9-默认" tabindex="-1"><a class="header-anchor" href="#g1-jdk9-默认"><span>G1（JDK9 默认）</span></a></h2><ul><li>区域化管理，预估停顿时间。</li><li>将堆划分为多个 Region，不要求连续。</li><li>可预测停顿时间：-XX:MaxGCPauseMillis=200</li><li>适合大堆内存（&gt;6GB）。</li><li>参数：-XX:+UseG1GC</li></ul><h2 id="zgc-jdk11" tabindex="-1"><a class="header-anchor" href="#zgc-jdk11"><span>ZGC（JDK11+）</span></a></h2><ul><li>子代收集，低延迟，支持大堆内存。</li><li>STW 时间 &lt; 10ms，支持 TB 级堆。</li><li>使用染色指针和读屏障技术。</li><li>参数：-XX:+UseZGC</li></ul><h2 id="shenandoah-jdk12" tabindex="-1"><a class="header-anchor" href="#shenandoah-jdk12"><span>Shenandoah（JDK12+）</span></a></h2><ul><li>红帽贡献，低停顿并发压缩。</li><li>STW 时间 &lt; 10ms，与 ZGC 类似。</li><li>使用 Brooks Forwarding 指针。</li><li>参数：-XX:+UseShenandoahGC</li></ul><h2 id="generational-zgc-jdk21" tabindex="-1"><a class="header-anchor" href="#generational-zgc-jdk21"><span>Generational ZGC（JDK21）</span></a></h2><ul><li>支持分代，结合低延迟与吞吐量。</li><li>分为年轻代和老年代，减少扫描范围。</li><li>参数：-XX:+UseZGC -XX:+ZGenerational</li></ul><h2 id="epsilon" tabindex="-1"><a class="header-anchor" href="#epsilon"><span>Epsilon</span></a></h2><ul><li>不做任何垃圾收集，用于测试。</li><li>适合短生命周期的应用或性能测试。</li><li>参数：-XX:+UseEpsilonGC</li></ul><h2 id="gc-触发条件" tabindex="-1"><a class="header-anchor" href="#gc-触发条件"><span>GC 触发条件</span></a></h2><h3 id="young-gc-触发条件" tabindex="-1"><a class="header-anchor" href="#young-gc-触发条件"><span>Young GC 触发条件</span></a></h3><ol><li><strong>Eden 区满了</strong>：新对象分配时 Eden 区不足。</li><li><strong>TLAB 分配失败</strong>：线程本地分配缓冲区不足。</li></ol><h3 id="full-gc-触发条件" tabindex="-1"><a class="header-anchor" href="#full-gc-触发条件"><span>Full GC 触发条件</span></a></h3><ol><li><strong>老年代空间不足</strong>：对象晋升或大对象分配时老年代不足。</li><li><strong>方法区空间不足</strong>：元空间或永久代空间不足。</li><li><strong>显式调用 System.gc()</strong>：建议 JVM 执行 GC（不保证执行）。</li><li><strong>堆转储时</strong>：jmap -dump 或 -XX:+HeapDumpOnOutOfMemoryError。</li><li><strong>CMS 失败</strong>：CMS 并发失败时退化为 Serial Old。</li><li><strong>G1 转移失败</strong>：G1 没有足够的空闲 Region。</li></ol><h2 id="stw-stop-the-world" tabindex="-1"><a class="header-anchor" href="#stw-stop-the-world"><span>STW（Stop The World）</span></a></h2><h3 id="什么是-stw" tabindex="-1"><a class="header-anchor" href="#什么是-stw"><span>什么是 STW</span></a></h3><ul><li>GC 期间所有应用线程暂停。</li><li>只有 GC 线程运行，无法响应请求。</li></ul><h3 id="stw-时间对比" tabindex="-1"><a class="header-anchor" href="#stw-时间对比"><span>STW 时间对比</span></a></h3><table><thead><tr><th>收集器</th><th>STW 时间</th><th>说明</th></tr></thead><tbody><tr><td>Serial</td><td>长</td><td>单线程，适合小堆</td></tr><tr><td>Parallel</td><td>中</td><td>多线程，吞吐量优先</td></tr><tr><td>CMS</td><td>短</td><td>并发标记，减少 STW</td></tr><tr><td>G1</td><td>可控</td><td>可设置目标停顿时间</td></tr><tr><td>ZGC</td><td>极短</td><td>&lt; 10ms</td></tr><tr><td>Shenandoah</td><td>极短</td><td>&lt; 10ms</td></tr></tbody></table><h3 id="减少-stw-的方法" tabindex="-1"><a class="header-anchor" href="#减少-stw-的方法"><span>减少 STW 的方法</span></a></h3><ol><li><strong>选择合适的收集器</strong>：低延迟场景选择 G1、ZGC。</li><li><strong>调整堆大小</strong>：避免频繁 GC。</li><li><strong>优化对象分配</strong>：减少临时对象，使用对象池。</li><li><strong>调优 GC 参数</strong>：设置合理的停顿时间目标。</li></ol><h2 id="gc-分代策略对比" tabindex="-1"><a class="header-anchor" href="#gc-分代策略对比"><span>GC 分代策略对比</span></a></h2><h3 id="分代收集器" tabindex="-1"><a class="header-anchor" href="#分代收集器"><span>分代收集器</span></a></h3><table><thead><tr><th>收集器</th><th>新生代</th><th>老年代</th><th>STW</th><th>适用场景</th></tr></thead><tbody><tr><td>Serial</td><td>Serial</td><td>Serial</td><td>长</td><td>小内存、单核</td></tr><tr><td>Parallel</td><td>Parallel Scavenge</td><td>Parallel Old</td><td>中</td><td>多核、吞吐量优先</td></tr><tr><td>CMS</td><td>ParNew</td><td>CMS</td><td>短</td><td>低延迟（已淘汰）</td></tr><tr><td>G1</td><td>G1</td><td>G1</td><td>可控</td><td>大堆、平衡延迟和吞吐</td></tr></tbody></table><h3 id="非分代收集器" tabindex="-1"><a class="header-anchor" href="#非分代收集器"><span>非分代收集器</span></a></h3><table><thead><tr><th>收集器</th><th>新生代</th><th>老年代</th><th>STW</th><th>适用场景</th></tr></thead><tbody><tr><td>ZGC</td><td>ZGC</td><td>ZGC</td><td>极短</td><td>超低延迟、超大堆</td></tr><tr><td>Shenandoah</td><td>Shenandoah</td><td>Shenandoah</td><td>极短</td><td>超低延迟、超大堆</td></tr></tbody></table><h3 id="分代-vs-非分代" tabindex="-1"><a class="header-anchor" href="#分代-vs-非分代"><span>分代 vs 非分代</span></a></h3><table><thead><tr><th>特性</th><th>分代收集</th><th>非分代收集</th></tr></thead><tbody><tr><td>内存布局</td><td>年轻代 + 老年代</td><td>统一内存区域</td></tr><tr><td>收集算法</td><td>复制 + 标记整理</td><td>标记-整理</td></tr><tr><td>吞吐量</td><td>高</td><td>中</td></tr><tr><td>延迟</td><td>中</td><td>极低</td></tr><tr><td>适用场景</td><td>通用场景</td><td>低延迟、大堆</td></tr></tbody></table><h2 id="gc-算法" tabindex="-1"><a class="header-anchor" href="#gc-算法"><span>GC 算法</span></a></h2><h3 id="标记-清除-mark-sweep" tabindex="-1"><a class="header-anchor" href="#标记-清除-mark-sweep"><span>标记-清除（Mark-Sweep）</span></a></h3><ul><li>分为标记和清除两个阶段。</li><li>优点：不需要额外空间。</li><li>缺点：产生内存碎片。</li></ul><h3 id="标记-整理-mark-compact" tabindex="-1"><a class="header-anchor" href="#标记-整理-mark-compact"><span>标记-整理（Mark-Compact）</span></a></h3><ul><li>标记后将存活对象向一端移动。</li><li>优点：无内存碎片。</li><li>缺点：移动对象成本高。</li></ul><h3 id="复制-copying" tabindex="-1"><a class="header-anchor" href="#复制-copying"><span>复制（Copying）</span></a></h3><ul><li>将存活对象复制到另一块区域。</li><li>优点：无内存碎片，效率高。</li><li>缺点：需要双倍空间。</li></ul><h3 id="分代收集-generational" tabindex="-1"><a class="header-anchor" href="#分代收集-generational"><span>分代收集（Generational）</span></a></h3><ul><li>新生代使用复制算法。</li><li>老年代使用标记-整理或标记-清除算法。</li><li>优点：针对不同代的特点优化。</li></ul>',47)]))}const h=t(d,[["render",n],["__file","4_garbage_collectors.html.vue"]]),o=JSON.parse('{"path":"/jvm/4_garbage_collectors.html","title":"垃圾收集器对比","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"Serial","slug":"serial","link":"#serial","children":[]},{"level":2,"title":"ParNew","slug":"parnew","link":"#parnew","children":[]},{"level":2,"title":"Parallel Scavenge / Parallel Old","slug":"parallel-scavenge-parallel-old","link":"#parallel-scavenge-parallel-old","children":[]},{"level":2,"title":"CMS（已淘汰）","slug":"cms-已淘汰","link":"#cms-已淘汰","children":[]},{"level":2,"title":"G1（JDK9 默认）","slug":"g1-jdk9-默认","link":"#g1-jdk9-默认","children":[]},{"level":2,"title":"ZGC（JDK11+）","slug":"zgc-jdk11","link":"#zgc-jdk11","children":[]},{"level":2,"title":"Shenandoah（JDK12+）","slug":"shenandoah-jdk12","link":"#shenandoah-jdk12","children":[]},{"level":2,"title":"Generational ZGC（JDK21）","slug":"generational-zgc-jdk21","link":"#generational-zgc-jdk21","children":[]},{"level":2,"title":"Epsilon","slug":"epsilon","link":"#epsilon","children":[]},{"level":2,"title":"GC 触发条件","slug":"gc-触发条件","link":"#gc-触发条件","children":[{"level":3,"title":"Young GC 触发条件","slug":"young-gc-触发条件","link":"#young-gc-触发条件","children":[]},{"level":3,"title":"Full GC 触发条件","slug":"full-gc-触发条件","link":"#full-gc-触发条件","children":[]}]},{"level":2,"title":"STW（Stop The World）","slug":"stw-stop-the-world","link":"#stw-stop-the-world","children":[{"level":3,"title":"什么是 STW","slug":"什么是-stw","link":"#什么是-stw","children":[]},{"level":3,"title":"STW 时间对比","slug":"stw-时间对比","link":"#stw-时间对比","children":[]},{"level":3,"title":"减少 STW 的方法","slug":"减少-stw-的方法","link":"#减少-stw-的方法","children":[]}]},{"level":2,"title":"GC 分代策略对比","slug":"gc-分代策略对比","link":"#gc-分代策略对比","children":[{"level":3,"title":"分代收集器","slug":"分代收集器","link":"#分代收集器","children":[]},{"level":3,"title":"非分代收集器","slug":"非分代收集器","link":"#非分代收集器","children":[]},{"level":3,"title":"分代 vs 非分代","slug":"分代-vs-非分代","link":"#分代-vs-非分代","children":[]}]},{"level":2,"title":"GC 算法","slug":"gc-算法","link":"#gc-算法","children":[{"level":3,"title":"标记-清除（Mark-Sweep）","slug":"标记-清除-mark-sweep","link":"#标记-清除-mark-sweep","children":[]},{"level":3,"title":"标记-整理（Mark-Compact）","slug":"标记-整理-mark-compact","link":"#标记-整理-mark-compact","children":[]},{"level":3,"title":"复制（Copying）","slug":"复制-copying","link":"#复制-copying","children":[]},{"level":3,"title":"分代收集（Generational）","slug":"分代收集-generational","link":"#分代收集-generational","children":[]}]}],"git":{"updatedTime":1771046824000,"contributors":[{"name":"hello0709","username":"hello0709","email":"1154937362@qq.com","commits":2,"url":"https://github.com/hello0709"}]},"filePathRelative":"jvm/4_garbage_collectors.md"}');export{h as comp,o as data};
