import{_ as l,c as a,a as n,o as s}from"./app-0Exyoz7n.js";const i={};function r(t,e){return s(),a("div",null,e[0]||(e[0]=[n('<h1 id="高并发指标" tabindex="-1"><a class="header-anchor" href="#高并发指标"><span>高并发指标</span></a></h1><h2 id="一、高并发常见指标" tabindex="-1"><a class="header-anchor" href="#一、高并发常见指标"><span>一、高并发常见指标：</span></a></h2><h3 id="_1、-qps-queries-per-second" tabindex="-1"><a class="header-anchor" href="#_1、-qps-queries-per-second"><span>1、 QPS（Queries Per Second）</span></a></h3><ul><li>QPS 是衡量系统处理请求能力的一个重要指标，表示系统每秒钟能够处理多少个请求。</li><li>在高并发系统中，QPS 高低直接决定了系统的吞吐量和响应能力。</li></ul><h3 id="_2、-tps-transactions-per-second" tabindex="-1"><a class="header-anchor" href="#_2、-tps-transactions-per-second"><span>2、 TPS（Transactions Per Second）</span></a></h3><ul><li>TPS 是表示每秒处理的事务数量，通常用于数据库或消息队列等需要进行事务处理的场景。</li><li>与 QPS 的区别在于，TPS 是针对带有业务逻辑的事务，而 QPS 更侧重于请求的数量。</li></ul><h3 id="_3、-rt-response-time" tabindex="-1"><a class="header-anchor" href="#_3、-rt-response-time"><span>3、 RT（Response Time）</span></a></h3><ul><li>RT 用来衡量系统对一个请求的响应速度，即从客户端发起请求到接收到响应的时间。</li><li>通常以毫秒（ms）为单位，RT 过高意味着系统存在性能瓶颈或资源不足。</li></ul><h3 id="_4、-并发数-concurrency" tabindex="-1"><a class="header-anchor" href="#_4、-并发数-concurrency"><span>4、 并发数（Concurrency）</span></a></h3><ul><li>并发数是指在同一时间内，系统能够处理的并发请求数量。它是衡量系统并发能力的一个重要维度。</li><li>高并发的系统需要通过负载均衡、分布式架构等方式来扩展并发数。</li></ul><h3 id="_5、-吞吐量-throughput" tabindex="-1"><a class="header-anchor" href="#_5、-吞吐量-throughput"><span>5、 吞吐量（Throughput）</span></a></h3><ul><li>吞吐量是指单位时间内系统可以处理的请求或数据的数量，通常与 QPS、TPS、并发数和带宽等指标结合使用。</li><li>高吞吐量通常表明系统可以在较短时间内处理大量数据。</li></ul><h2 id="二、常用的组件-qps" tabindex="-1"><a class="header-anchor" href="#二、常用的组件-qps"><span>二、常用的组件 QPS</span></a></h2><h3 id="_1、-tomcat-与-undertow" tabindex="-1"><a class="header-anchor" href="#_1、-tomcat-与-undertow"><span>1、 <strong>Tomcat 与 Undertow</strong></span></a></h3><ul><li><strong>Tomcat</strong>：作为常用的 Java Web 容器，Tomcat 的 QPS 通常受限于服务器硬件、线程池配置、JVM 设置等因素。在高并发环境中，Tomcat 的 QPS 一般可以达到几千到数万（具体根据配置而定）。</li><li><strong>Undertow</strong>：相比 Tomcat，Undertow 是一个更轻量级的 Web 服务器，能够提供更高的并发性能，特别是在 HTTP2 和异步处理方面表现更好。在相同硬件配置下，Undertow 的 QPS 通常能比 Tomcat 更高，适合用于微服务架构和高并发场景。</li></ul><h3 id="_2、-mysql" tabindex="-1"><a class="header-anchor" href="#_2、-mysql"><span>2、 <strong>MySQL</strong></span></a></h3><ul><li><p>MySQL 的 QPS 与数据表设计、索引优化、查询语句优化、硬件配置和并发连接数等因素有关。在高并发场景中，合理的缓存和负载均衡策略可以显著提高 QPS。</p><ul><li><strong>普通查询</strong>：在高效索引和优化查询的情况下，MySQL 每秒可以处理数千到数万条简单查询。</li><li><strong>事务性操作</strong>：涉及事务和较复杂查询时，QPS 会降低，可能在数百到几千条之间。</li></ul></li></ul><h3 id="_3、-redis" tabindex="-1"><a class="header-anchor" href="#_3、-redis"><span>3、 <strong>Redis</strong></span></a></h3><ul><li><p>Redis 是一个高性能的内存数据库，主要用于缓存和会话存储。由于其基于内存存储，Redis 的 QPS 可以非常高，通常在数十万甚至百万级别。</p><ul><li><strong>单线程模型</strong>：Redis 是单线程的，但其事件驱动模型和高效的 I/O 操作使得它能够处理大量请求。</li><li><strong>高并发下的吞吐量</strong>：Redis 的吞吐量通常高于 MySQL，特别是在数据量较小且操作简单时（如缓存查询、计数器等）。</li><li><strong>Redis Cluster</strong>：通过分片扩展，单集群的 QPS 可线性提升，支持百万级别并发。</li></ul></li></ul><h3 id="_4、-消息队列-mq" tabindex="-1"><a class="header-anchor" href="#_4、-消息队列-mq"><span>4、 <strong>消息队列（MQ）</strong></span></a></h3><ul><li><p>消息队列（如 Kafka、RabbitMQ、RocketMQ）在高并发系统中用于解耦各个模块，提升系统可扩展性。它的 QPS 取决于队列的实现、消息大小、网络带宽等因素。</p><ul><li><strong>Kafka</strong>：通常可以支持数百万的消息每秒，特别适合处理大规模的日志数据和实时流处理任务。Kafka 利用分区机制和批量写入，达到极高吞吐量。</li><li><strong>RabbitMQ</strong>：虽然支持高并发，但由于其较为复杂的路由机制，通常 QPS 会稍低于 Kafka，适合需要较高消息可靠性的场景。</li><li><strong>RocketMQ</strong>：基于分布式架构，能够承载高吞吐量，支持百万级别的 QPS，且支持事务消息。</li><li><strong>ActiveMQ</strong>：作为老牌 MQ，QPS 一般较 Kafka 和 RocketMQ 低，适合中小规模系统。</li></ul></li></ul><h3 id="_5、-elasticsearch" tabindex="-1"><a class="header-anchor" href="#_5、-elasticsearch"><span>5、 <strong>Elasticsearch</strong></span></a></h3><ul><li><p>Elasticsearch 是一个分布式搜索引擎，广泛用于日志、监控和全文搜索场景。</p><ul><li>在合理硬件和索引设计下，Elasticsearch 可以达到每秒数万到数十万的查询请求。</li><li>写入吞吐量视索引结构和副本数量而定，一般在几千到几万条每秒。</li><li>通过分片和副本机制，支持横向扩展，提升整体 QPS。</li></ul></li></ul><h3 id="_6、-nginx" tabindex="-1"><a class="header-anchor" href="#_6、-nginx"><span>6、 <strong>Nginx</strong></span></a></h3><ul><li>作为高性能的反向代理和负载均衡器，Nginx 可轻松支持每秒数十万甚至百万级的 HTTP 请求。</li><li>在静态资源分发、负载均衡和反向代理中表现优异，通常是高并发系统的前端入口。</li><li>通过事件驱动和异步处理，Nginx 的性能远超传统多线程服务器。</li></ul><h3 id="_7、-mongodb" tabindex="-1"><a class="header-anchor" href="#_7、-mongodb"><span>7、 <strong>MongoDB</strong></span></a></h3><ul><li>MongoDB 是文档型 NoSQL 数据库，适合海量非结构化数据存储。</li><li>单节点 QPS 可达数千至数万（取决于查询复杂度和索引优化）。</li><li>通过分片集群，可扩展至百万级 QPS，适合高并发读写场景。</li><li>写操作较快，但在强一致性需求场景下性能可能受限。</li></ul><h3 id="_8、-apache-cassandra" tabindex="-1"><a class="header-anchor" href="#_8、-apache-cassandra"><span>8、 <strong>Apache Cassandra</strong></span></a></h3><ul><li>Cassandra 是分布式列存储数据库，专为高可用和高写入吞吐量设计。</li><li>在大规模集群环境中，Cassandra 可以实现每秒数百万的写入操作。</li><li>读写性能稳定且支持线性扩展，适合 IoT、大数据等场景。</li></ul><h3 id="_9、-zookeeper" tabindex="-1"><a class="header-anchor" href="#_9、-zookeeper"><span>9、 <strong>ZooKeeper</strong></span></a></h3><ul><li>ZooKeeper 主要作为分布式协调服务使用，QPS 不会非常高，通常在几千左右。</li><li>它更多关注一致性和可靠性，适合配置管理、分布式锁等场景。</li></ul><h3 id="_10、-grpc" tabindex="-1"><a class="header-anchor" href="#_10、-grpc"><span>10、 <strong>gRPC</strong></span></a></h3><ul><li>作为高性能的 RPC 框架，gRPC 支持 HTTP/2，支持双向流和多路复用。</li><li>在相同网络条件下，gRPC 的 QPS 通常比传统 RESTful API 更高，支持几十万的调用吞吐量。</li><li>适合微服务间高频通信，特别是对延迟敏感的场景。</li></ul>',33)]))}const c=l(i,[["render",r],["__file","3_Indicator.html.vue"]]),h=JSON.parse('{"path":"/high-concurrency/3_Indicator.html","title":"高并发指标","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"一、高并发常见指标：","slug":"一、高并发常见指标","link":"#一、高并发常见指标","children":[{"level":3,"title":"1、 QPS（Queries Per Second）","slug":"_1、-qps-queries-per-second","link":"#_1、-qps-queries-per-second","children":[]},{"level":3,"title":"2、 TPS（Transactions Per Second）","slug":"_2、-tps-transactions-per-second","link":"#_2、-tps-transactions-per-second","children":[]},{"level":3,"title":"3、 RT（Response Time）","slug":"_3、-rt-response-time","link":"#_3、-rt-response-time","children":[]},{"level":3,"title":"4、 并发数（Concurrency）","slug":"_4、-并发数-concurrency","link":"#_4、-并发数-concurrency","children":[]},{"level":3,"title":"5、 吞吐量（Throughput）","slug":"_5、-吞吐量-throughput","link":"#_5、-吞吐量-throughput","children":[]}]},{"level":2,"title":"二、常用的组件 QPS","slug":"二、常用的组件-qps","link":"#二、常用的组件-qps","children":[{"level":3,"title":"1、 Tomcat 与 Undertow","slug":"_1、-tomcat-与-undertow","link":"#_1、-tomcat-与-undertow","children":[]},{"level":3,"title":"2、 MySQL","slug":"_2、-mysql","link":"#_2、-mysql","children":[]},{"level":3,"title":"3、 Redis","slug":"_3、-redis","link":"#_3、-redis","children":[]},{"level":3,"title":"4、 消息队列（MQ）","slug":"_4、-消息队列-mq","link":"#_4、-消息队列-mq","children":[]},{"level":3,"title":"5、 Elasticsearch","slug":"_5、-elasticsearch","link":"#_5、-elasticsearch","children":[]},{"level":3,"title":"6、 Nginx","slug":"_6、-nginx","link":"#_6、-nginx","children":[]},{"level":3,"title":"7、 MongoDB","slug":"_7、-mongodb","link":"#_7、-mongodb","children":[]},{"level":3,"title":"8、 Apache Cassandra","slug":"_8、-apache-cassandra","link":"#_8、-apache-cassandra","children":[]},{"level":3,"title":"9、 ZooKeeper","slug":"_9、-zookeeper","link":"#_9、-zookeeper","children":[]},{"level":3,"title":"10、 gRPC","slug":"_10、-grpc","link":"#_10、-grpc","children":[]}]}],"git":{"updatedTime":1747496471000,"contributors":[{"name":"hanchen","username":"hanchen","email":"1154937362@qq.com","commits":2,"url":"https://github.com/hanchen"},{"name":"Clarence","username":"Clarence","email":"1154937362@qq.com","commits":8,"url":"https://github.com/Clarence"},{"name":"hello0709","username":"hello0709","email":"1154937362@qq.com","commits":1,"url":"https://github.com/hello0709"}]},"filePathRelative":"high-concurrency/3_Indicator.md"}');export{c as comp,h as data};
