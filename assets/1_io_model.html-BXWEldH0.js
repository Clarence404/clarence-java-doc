import{_ as s,c as a,a as e,o as t}from"./app-lUQL8Cel.js";const p={};function o(l,n){return t(),a("div",null,n[0]||(n[0]=[e(`<h1 id="io-模型" tabindex="-1"><a class="header-anchor" href="#io-模型"><span>IO 模型</span></a></h1><div class="hint-container warning"><p class="hint-container-title">Todo 理解后优化</p></div><p>在网络编程中，IO 模型和 Reactor 模型是两种重要的并发处理方式，主要用于高并发网络服务器的设计，特别是 <strong>Java 的 Netty、NIO、Spring WebFlux</strong> 等框架都会涉及。</p><hr><p>IO 模型主要描述 <strong>操作系统如何处理网络 IO 请求</strong>。常见的 IO 模型有 5 种：</p><h3 id="_1、-阻塞io-blocking-io" tabindex="-1"><a class="header-anchor" href="#_1、-阻塞io-blocking-io"><span><strong>1、 阻塞IO（Blocking IO）</strong></span></a></h3><ul><li><p><strong>特点</strong>：每个请求需要一个线程处理，线程会一直阻塞，直到数据到达并完成读取。</p></li><li><p><strong>缺点</strong>：线程资源浪费，在高并发情况下容易造成性能瓶颈。</p></li><li><p><strong>示例</strong>：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token class-name">ServerSocket</span> serverSocket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServerSocket</span><span class="token punctuation">(</span><span class="token number">8080</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">Socket</span> socket <span class="token operator">=</span> serverSocket<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 阻塞等待连接</span></span>
<span class="line"><span class="token class-name">InputStream</span> inputStream <span class="token operator">=</span> socket<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">int</span> data <span class="token operator">=</span> inputStream<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 阻塞等待数据</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h3 id="_2、-非阻塞io-non-blocking-io" tabindex="-1"><a class="header-anchor" href="#_2、-非阻塞io-non-blocking-io"><span><strong>2、 非阻塞IO（Non-Blocking IO）</strong></span></a></h3><ul><li><p><strong>特点</strong>：进程不断轮询检查数据是否准备好，如果没有数据，立即返回，不会阻塞线程。</p></li><li><p><strong>缺点</strong>：CPU 资源消耗大，需要不断轮询。</p></li><li><p><strong>示例</strong>：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line">socketChannel<span class="token punctuation">.</span><span class="token function">configureBlocking</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">int</span> bytesRead <span class="token operator">=</span> socketChannel<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 非阻塞读取</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h3 id="_3、io多路复用-multiplexing-io-select-epoll" tabindex="-1"><a class="header-anchor" href="#_3、io多路复用-multiplexing-io-select-epoll"><span><strong>3、IO多路复用（Multiplexing IO，Select/epoll）</strong></span></a></h3><ul><li><p><strong>特点</strong>：使用 <code>select</code> / <code>poll</code> / <code>epoll</code> 让单个线程管理多个连接，避免了多个线程的资源开销。</p></li><li><p><strong>优点</strong>：适用于高并发场景，不需要每个连接创建一个线程。</p></li><li><p><strong>示例（Java NIO）</strong>：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token class-name">Selector</span> selector <span class="token operator">=</span> <span class="token class-name">Selector</span><span class="token punctuation">.</span><span class="token keyword">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">socketChannel<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>selector<span class="token punctuation">,</span> <span class="token class-name">SelectionKey</span><span class="token punctuation">.</span><span class="token constant">OP_READ</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    selector<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 阻塞直到有事件发生</span></span>
<span class="line">    <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SelectionKey</span><span class="token punctuation">&gt;</span></span> keys <span class="token operator">=</span> selector<span class="token punctuation">.</span><span class="token function">selectedKeys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">SelectionKey</span> key <span class="token operator">:</span> keys<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">isReadable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">            <span class="token comment">// 处理可读事件</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h3 id="_4、信号驱动io-signal-driven-io" tabindex="-1"><a class="header-anchor" href="#_4、信号驱动io-signal-driven-io"><span><strong>4、信号驱动IO（Signal-driven IO）</strong></span></a></h3><ul><li><p><strong>特点</strong>：使用 <code>SIGIO</code> 信号通知应用程序数据已准备好。</p></li><li><p><strong>应用场景</strong>：很少用于 Java，更常见于 Linux 低级编程。</p></li></ul><h3 id="_5、异步io-asynchronous-io-aio" tabindex="-1"><a class="header-anchor" href="#_5、异步io-asynchronous-io-aio"><span><strong>5、异步IO（Asynchronous IO，AIO）</strong></span></a></h3><ul><li><p><strong>特点</strong>：IO 操作完全由内核负责，应用程序只需要在数据准备好后接收通知，无需轮询。</p></li><li><p><strong>优点</strong>：彻底的异步模型，适用于超高并发场景。</p></li><li><p><strong>示例（Java AIO）</strong>：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token class-name">AsynchronousServerSocketChannel</span> server <span class="token operator">=</span> <span class="token class-name">AsynchronousServerSocketChannel</span><span class="token punctuation">.</span><span class="token keyword">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">server<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">CompletionHandler</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">completed</span><span class="token punctuation">(</span><span class="token class-name">AsynchronousSocketChannel</span> channel<span class="token punctuation">,</span> <span class="token class-name">Object</span> attachment<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token comment">// 处理连接</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul>`,15)]))}const i=s(p,[["render",o],["__file","1_io_model.html.vue"]]),u=JSON.parse('{"path":"/netty/1_io_model.html","title":"IO 模型","lang":"en-US","frontmatter":{},"headers":[{"level":3,"title":"1、 阻塞IO（Blocking IO）","slug":"_1、-阻塞io-blocking-io","link":"#_1、-阻塞io-blocking-io","children":[]},{"level":3,"title":"2、 非阻塞IO（Non-Blocking IO）","slug":"_2、-非阻塞io-non-blocking-io","link":"#_2、-非阻塞io-non-blocking-io","children":[]},{"level":3,"title":"3、IO多路复用（Multiplexing IO，Select/epoll）","slug":"_3、io多路复用-multiplexing-io-select-epoll","link":"#_3、io多路复用-multiplexing-io-select-epoll","children":[]},{"level":3,"title":"4、信号驱动IO（Signal-driven IO）","slug":"_4、信号驱动io-signal-driven-io","link":"#_4、信号驱动io-signal-driven-io","children":[]},{"level":3,"title":"5、异步IO（Asynchronous IO，AIO）","slug":"_5、异步io-asynchronous-io-aio","link":"#_5、异步io-asynchronous-io-aio","children":[]}],"git":{"updatedTime":1742735410000,"contributors":[{"name":"Clarence","username":"Clarence","email":"1154937362@qq.com","commits":3,"url":"https://github.com/Clarence"},{"name":"hanchen","username":"hanchen","email":"1154937362@qq.com","commits":4,"url":"https://github.com/hanchen"}]},"filePathRelative":"netty/1_io_model.md"}');export{i as comp,u as data};
