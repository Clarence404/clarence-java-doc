import{_ as a,c as e,a as s,o as t}from"./app-xkIC7ADQ.js";const l={};function c(o,n){return t(),e("div",null,n[0]||(n[0]=[s(`<h1 id="java-并发基础" tabindex="-1"><a class="header-anchor" href="#java-并发基础"><span>Java 并发基础</span></a></h1><p>参考链接：</p><blockquote><p><a href="https://gitee.com/Doocs/advanced-java#%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9E%B6%E6%9E%84" target="_blank" rel="noopener noreferrer">https://gitee.com/Doocs/advanced-java</a></p></blockquote><blockquote><p><a href="https://mp.weixin.qq.com/s/eTQwT-zFgHgNVJ_nNAZidw" target="_blank" rel="noopener noreferrer">实现异步的9种方式-捡田螺的小男孩</a></p></blockquote><h2 id="一、juc-atomic" tabindex="-1"><a class="header-anchor" href="#一、juc-atomic"><span>一、JUC - Atomic</span></a></h2><p>Java 中的 <code>java.util.concurrent.atomic</code> 包提供了一组<strong>原子变量类</strong>，主要用于<strong>高并发场景下的无锁编程</strong>，比起使用 <code>synchronized</code>，这些类可以提升程序的性能和吞吐量。</p><h3 id="_1、核心思想" tabindex="-1"><a class="header-anchor" href="#_1、核心思想"><span>1、核心思想</span></a></h3><p>CAS（Compare-And-Swap）是实现原子操作的核心思想，其工作原理如下：</p><ul><li><strong>比较内存中的值与预期值</strong>，如果一致，则将其更新为新的值。</li><li>它是一种<strong>乐观锁机制</strong>，通过尝试修改共享数据并检查是否发生了冲突来保证线程安全。</li></ul><h3 id="_2、常用分类" tabindex="-1"><a class="header-anchor" href="#_2、常用分类"><span>2、常用分类</span></a></h3><h4 id="_2-1-基本类型原子类" tabindex="-1"><a class="header-anchor" href="#_2-1-基本类型原子类"><span>2.1. 基本类型原子类</span></a></h4><table><thead><tr><th>类名</th><th>对应类型</th></tr></thead><tbody><tr><td><code>AtomicInteger</code></td><td>int</td></tr><tr><td><code>AtomicLong</code></td><td>long</td></tr><tr><td><code>AtomicBoolean</code></td><td>boolean</td></tr></tbody></table><p><strong>示例：</strong></p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token class-name">AtomicInteger</span> counter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    counter<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// +1</span></span>
<span class="line">    counter<span class="token punctuation">.</span><span class="token function">addAndGet</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// +5</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_2-2-引用类型原子类" tabindex="-1"><a class="header-anchor" href="#_2-2-引用类型原子类"><span>2.2 引用类型原子类</span></a></h4><table><thead><tr><th>类名</th><th>说明</th></tr></thead><tbody><tr><td><code>AtomicReference&lt;T&gt;</code></td><td>原子更新引用</td></tr><tr><td><code>AtomicStampedReference&lt;T&gt;</code></td><td>带版本戳，解决ABA问题</td></tr><tr><td><code>AtomicMarkableReference&lt;T&gt;</code></td><td>带布尔标记</td></tr></tbody></table><p><strong>ABA问题解决示例：</strong></p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token class-name">AtomicStampedReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> ref <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicStampedReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> stampHolder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token class-name">Integer</span> value <span class="token operator">=</span> ref<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>stampHolder<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    ref<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> stampHolder<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> stampHolder<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_2-3-数组原子类" tabindex="-1"><a class="header-anchor" href="#_2-3-数组原子类"><span>2.3 数组原子类</span></a></h4><table><thead><tr><th>类名</th><th>说明</th></tr></thead><tbody><tr><td><code>AtomicIntegerArray</code></td><td>原子更新整型数组</td></tr><tr><td><code>AtomicLongArray</code></td><td>原子更新长整型数组</td></tr><tr><td><code>AtomicReferenceArray&lt;T&gt;</code></td><td>原子更新引用数组</td></tr></tbody></table><h4 id="_3-高级类-longadder-longaccumulator" tabindex="-1"><a class="header-anchor" href="#_3-高级类-longadder-longaccumulator"><span>3. 高级类：<code>LongAdder</code> / <code>LongAccumulator</code></span></a></h4><p>为了解决高并发下 <code>AtomicLong</code> 的热点问题，引入了分段累加器：</p><div class="language-java line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre><code><span class="line"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token class-name">LongAdder</span> adder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LongAdder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    adder<span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 高并发下效率更好</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_4、优缺点对比" tabindex="-1"><a class="header-anchor" href="#_4、优缺点对比"><span>4、优缺点对比</span></a></h3><table><thead><tr><th>特点</th><th>Atomic 原子类</th><th>synchronized</th></tr></thead><tbody><tr><td>是否阻塞</td><td>否（非阻塞）</td><td>是</td></tr><tr><td>性能</td><td>高</td><td>中</td></tr><tr><td>是否公平</td><td>否</td><td>是</td></tr><tr><td>可读性</td><td>一般</td><td>高</td></tr></tbody></table><h3 id="_5、使用建议" tabindex="-1"><a class="header-anchor" href="#_5、使用建议"><span>5、使用建议</span></a></h3><ul><li><p>在<strong>并发量大</strong>但<strong>冲突概率低</strong>的场景中使用 Atomic 类。</p></li><li><p>如果涉及多个变量的原子性，则需要使用 <strong><code>synchronized</code></strong> 或 <strong><code>Lock</code></strong>。</p></li></ul><h2 id="二、juc-lock" tabindex="-1"><a class="header-anchor" href="#二、juc-lock"><span>二、JUC - LOCK</span></a></h2><h3 id="synchronized" tabindex="-1"><a class="header-anchor" href="#synchronized"><span>synchronized</span></a></h3><h3 id="reentrantlock" tabindex="-1"><a class="header-anchor" href="#reentrantlock"><span>ReentrantLock</span></a></h3><h3 id="countdownlatch-cyclicbarrier" tabindex="-1"><a class="header-anchor" href="#countdownlatch-cyclicbarrier"><span>CountDownLatch / CyclicBarrier</span></a></h3><h3 id="semaphore" tabindex="-1"><a class="header-anchor" href="#semaphore"><span>Semaphore</span></a></h3><h3 id="blockingqueue" tabindex="-1"><a class="header-anchor" href="#blockingqueue"><span>BlockingQueue</span></a></h3><h3 id="concurrenthashmap" tabindex="-1"><a class="header-anchor" href="#concurrenthashmap"><span>ConcurrentHashMap</span></a></h3><h2 id="三、juc-fork-join" tabindex="-1"><a class="header-anchor" href="#三、juc-fork-join"><span>三、JUC - Fork/Join</span></a></h2><h3 id="fork-join-工作窃取算法" tabindex="-1"><a class="header-anchor" href="#fork-join-工作窃取算法"><span>Fork/Join 工作窃取算法</span></a></h3><h3 id="任务拆分与合并" tabindex="-1"><a class="header-anchor" href="#任务拆分与合并"><span>任务拆分与合并</span></a></h3><h2 id="四、juc-completablefuture" tabindex="-1"><a class="header-anchor" href="#四、juc-completablefuture"><span>四、JUC - CompletableFuture</span></a></h2><h3 id="_1-completablefuture-简介" tabindex="-1"><a class="header-anchor" href="#_1-completablefuture-简介"><span>1. CompletableFuture 简介</span></a></h3><ul><li>介绍 <code>CompletableFuture</code> 的定义和基本用途。</li><li>与 <code>Future</code> 的区别。</li></ul><h3 id="_2-completablefuture-常用操作" tabindex="-1"><a class="header-anchor" href="#_2-completablefuture-常用操作"><span>2. CompletableFuture 常用操作</span></a></h3><ul><li>创建 <code>CompletableFuture</code> 的方式。</li><li><code>thenApply</code>、<code>thenAccept</code>、<code>thenRun</code> 等常用方法。</li><li>异常处理 (<code>handle</code>、<code>exceptionally</code> 等)。</li></ul><h3 id="_3-组合异步任务" tabindex="-1"><a class="header-anchor" href="#_3-组合异步任务"><span>3. 组合异步任务</span></a></h3><ul><li><code>thenCompose</code> 和 <code>thenCombine</code> 的使用。</li><li><code>allOf</code> 和 <code>anyOf</code> 的异步任务组合。</li></ul><h3 id="_4-完成和取消任务" tabindex="-1"><a class="header-anchor" href="#_4-完成和取消任务"><span>4. 完成和取消任务</span></a></h3><ul><li>使用 <code>complete</code> 方法完成任务。</li><li>使用 <code>cancel</code> 方法取消任务。</li></ul><h3 id="_5-相关坑和陷阱" tabindex="-1"><a class="header-anchor" href="#_5-相关坑和陷阱"><span>5. 相关坑和陷阱</span></a></h3><ul><li>线程池管理。</li><li>异常处理。</li><li>阻塞与非阻塞操作。</li></ul><h2 id="五、juc-异步编程" tabindex="-1"><a class="header-anchor" href="#五、juc-异步编程"><span>五、JUC - 异步编程</span></a></h2><h3 id="_1-异步编程概述" tabindex="-1"><a class="header-anchor" href="#_1-异步编程概述"><span>1. 异步编程概述</span></a></h3><ul><li>异步编程的基本概念。</li><li>为什么需要异步编程？</li></ul><h3 id="_2-异步任务的设计与实现" tabindex="-1"><a class="header-anchor" href="#_2-异步任务的设计与实现"><span>2. 异步任务的设计与实现</span></a></h3><ul><li>使用 <code>ExecutorService</code> 和 <code>Callable</code> 进行任务调度。</li><li>如何设计高效的异步任务执行模型。</li></ul><h3 id="_3-异步编程的模式" tabindex="-1"><a class="header-anchor" href="#_3-异步编程的模式"><span>3. 异步编程的模式</span></a></h3><ul><li>发布-订阅模式。</li><li>生产者-消费者模式。</li><li>任务链模式。</li></ul><h3 id="_4-异步编程的挑战与最佳实践" tabindex="-1"><a class="header-anchor" href="#_4-异步编程的挑战与最佳实践"><span>4. 异步编程的挑战与最佳实践</span></a></h3><ul><li>线程管理与资源消耗。</li><li>错误处理与回调机制。</li><li>如何避免死锁、竞争条件等问题。</li></ul>`,57)]))}const i=a(l,[["render",c],["__file","0_concurrent.html.vue"]]),r=JSON.parse('{"path":"/high-con/0_concurrent.html","title":"Java 并发基础","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"一、JUC - Atomic","slug":"一、juc-atomic","link":"#一、juc-atomic","children":[{"level":3,"title":"1、核心思想","slug":"_1、核心思想","link":"#_1、核心思想","children":[]},{"level":3,"title":"2、常用分类","slug":"_2、常用分类","link":"#_2、常用分类","children":[]},{"level":3,"title":"4、优缺点对比","slug":"_4、优缺点对比","link":"#_4、优缺点对比","children":[]},{"level":3,"title":"5、使用建议","slug":"_5、使用建议","link":"#_5、使用建议","children":[]}]},{"level":2,"title":"二、JUC - LOCK","slug":"二、juc-lock","link":"#二、juc-lock","children":[{"level":3,"title":"synchronized","slug":"synchronized","link":"#synchronized","children":[]},{"level":3,"title":"ReentrantLock","slug":"reentrantlock","link":"#reentrantlock","children":[]},{"level":3,"title":"CountDownLatch / CyclicBarrier","slug":"countdownlatch-cyclicbarrier","link":"#countdownlatch-cyclicbarrier","children":[]},{"level":3,"title":"Semaphore","slug":"semaphore","link":"#semaphore","children":[]},{"level":3,"title":"BlockingQueue","slug":"blockingqueue","link":"#blockingqueue","children":[]},{"level":3,"title":"ConcurrentHashMap","slug":"concurrenthashmap","link":"#concurrenthashmap","children":[]}]},{"level":2,"title":"三、JUC - Fork/Join","slug":"三、juc-fork-join","link":"#三、juc-fork-join","children":[{"level":3,"title":"Fork/Join 工作窃取算法","slug":"fork-join-工作窃取算法","link":"#fork-join-工作窃取算法","children":[]},{"level":3,"title":"任务拆分与合并","slug":"任务拆分与合并","link":"#任务拆分与合并","children":[]}]},{"level":2,"title":"四、JUC - CompletableFuture","slug":"四、juc-completablefuture","link":"#四、juc-completablefuture","children":[{"level":3,"title":"1. CompletableFuture 简介","slug":"_1-completablefuture-简介","link":"#_1-completablefuture-简介","children":[]},{"level":3,"title":"2. CompletableFuture 常用操作","slug":"_2-completablefuture-常用操作","link":"#_2-completablefuture-常用操作","children":[]},{"level":3,"title":"3. 组合异步任务","slug":"_3-组合异步任务","link":"#_3-组合异步任务","children":[]},{"level":3,"title":"4. 完成和取消任务","slug":"_4-完成和取消任务","link":"#_4-完成和取消任务","children":[]},{"level":3,"title":"5. 相关坑和陷阱","slug":"_5-相关坑和陷阱","link":"#_5-相关坑和陷阱","children":[]}]},{"level":2,"title":"五、JUC - 异步编程","slug":"五、juc-异步编程","link":"#五、juc-异步编程","children":[{"level":3,"title":"1. 异步编程概述","slug":"_1-异步编程概述","link":"#_1-异步编程概述","children":[]},{"level":3,"title":"2. 异步任务的设计与实现","slug":"_2-异步任务的设计与实现","link":"#_2-异步任务的设计与实现","children":[]},{"level":3,"title":"3. 异步编程的模式","slug":"_3-异步编程的模式","link":"#_3-异步编程的模式","children":[]},{"level":3,"title":"4. 异步编程的挑战与最佳实践","slug":"_4-异步编程的挑战与最佳实践","link":"#_4-异步编程的挑战与最佳实践","children":[]}]}],"git":{"updatedTime":1752557729000,"contributors":[{"name":"hanchen","username":"hanchen","email":"1154937362@qq.com","commits":4,"url":"https://github.com/hanchen"},{"name":"Clarence","username":"Clarence","email":"1154937362@qq.com","commits":16,"url":"https://github.com/Clarence"},{"name":"hello0709","username":"hello0709","email":"1154937362@qq.com","commits":4,"url":"https://github.com/hello0709"}]},"filePathRelative":"high-con/0_concurrent.md"}');export{i as comp,r as data};
