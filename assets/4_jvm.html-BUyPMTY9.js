import{_ as e,c as n,a as i,o as l}from"./app-BNVKJjOr.js";const t="/clarence-java-doc/assets/how_jvm_run-DCNsWcEY.png",s="/clarence-java-doc/assets/jvm_model-3-BCO_2B.png",r="/clarence-java-doc/assets/mark_sweep-BNqLjyN1.png",c="/clarence-java-doc/assets/mark_copy-BQHop6-R.png",o="/clarence-java-doc/assets/mark_compact-CqoHJCoC.png",p="/clarence-java-doc/assets/garbage_collector_-nevT9VOh.png",h={};function m(d,a){return l(),n("div",null,a[0]||(a[0]=[i('<h1 id="java总结-jvm" tabindex="-1"><a class="header-anchor" href="#java总结-jvm"><span>Java总结-JVM</span></a></h1><h2 id="jvm是如何运行的" tabindex="-1"><a class="header-anchor" href="#jvm是如何运行的"><span>JVM是如何运行的？</span></a></h2><p>VM（Java Virtual Machine，Java虚拟机）是 Java 程序的运行环境，它负责将 Java 字节码翻译成机器代码并执行。也就是说 Java 代码之所以能够运行，主要是依靠 JVM 来实现的。</p><p>JVM 整体的大概执行流程是这样的：</p><ol><li>程序在执行之前先要把 Java 代码转换成字节码（class 文件），JVM 首先需要把字节码通过一定的方式<strong>类加载器（ClassLoader）</strong> 把文件加载到内存中<strong>运行时数据区（Runtime Data Area）</strong>；</li><li>但字节码文件是 JVM 的一套指令集规范，并不能直接交个底层操作系统去执行，因此需要特定的命令解析器，也就是 JVM 的执行引擎（Execution Engine）会<strong>将字节码翻译成底层系统指令再交由 CPU 去执行</strong>；</li><li>在执行的过程中，也需要调用其他语言的接口，如通过<strong>调用本地库接口（Native Interface）</strong> 来实现整个程序的运行，如下图所示： <img src="'+t+'" alt="img.png"></li></ol><p>所以，整体来看， JVM 主要通过分为以下 4 个部分，来执行 Java 程序的，它们分别是：</p><ul><li>类加载器（ClassLoader）</li><li>运行时数据区（Runtime Data Area）</li><li>执行引擎（Execution Engine）</li><li>本地库接口（Native Interface）</li></ul><h2 id="说说jvm的内存模型" tabindex="-1"><a class="header-anchor" href="#说说jvm的内存模型"><span>说说JVM的内存模型？</span></a></h2><p><img src="'+s+'" alt="img.png"></p><ul><li>程序计数器：负责追踪线程执行的字节码指令。</li><li>JVM栈：存储方法的局部变量、操作数栈和方法调用的栈帧，线程私有。</li><li>本地方法栈：支持本地方法的调用，通常与JVM栈功能类似。</li><li>堆：存储对象实例，是JVM内存中最大的区域，由垃圾回收器管理。</li><li>方法区/元空间：存储类的信息、常量池、静态变量等，JDK 8后由元空间代替永久代。</li></ul><h2 id="垃圾回收算法" tabindex="-1"><a class="header-anchor" href="#垃圾回收算法"><span>垃圾回收算法</span></a></h2><h3 id="_1、标记-清除" tabindex="-1"><a class="header-anchor" href="#_1、标记-清除"><span>1、标记-清除</span></a></h3><p><img src="'+r+'" alt="img.png"></p><div class="hint-container tip"><p class="hint-container-title">优点</p><p>可以看到，标记清除算法解决了引用计数算法中的循环引用的问题，没有从root节点引用的对象都会被回收。</p></div><div class="hint-container warning"><p class="hint-container-title">缺点</p><ul><li>效率较低，标记和清除两个动作都需要遍历所有的对象，并且在GC时，需要停止应用程序，对于交互性要求比较高的应用而言这个体验是非常差的。</li><li>通过标记清除算法清理出来的内存，碎片化较为严重，因为被回收的对象可能存在于内存的各个角落，所以清理出来的内存是不连贯的。</li></ul></div><h3 id="_2、标记-复制" tabindex="-1"><a class="header-anchor" href="#_2、标记-复制"><span>2、标记-复制</span></a></h3><p><img src="'+c+'" alt="img_1.png"></p><div class="hint-container warning"><p class="hint-container-title">缺点</p><p>但是这种算法：浪费内存</p></div><h3 id="_3、标记-压缩" tabindex="-1"><a class="header-anchor" href="#_3、标记-压缩"><span>3、标记-压缩</span></a></h3><p><img src="'+o+'" alt="img_2.png"></p><div class="hint-container warning"><p class="hint-container-title">缺点</p><p>但是这种算法：效率太低</p></div><p>三种算法都有问题，JVM采用三种的综合运用，产生了各种各样的GC垃圾回收器！</p><h2 id="垃圾回收器" tabindex="-1"><a class="header-anchor" href="#垃圾回收器"><span>垃圾回收器</span></a></h2><p><img src="'+p+'" alt="img.png"></p>',24)]))}const g=e(h,[["render",m],["__file","4_jvm.html.vue"]]),_=JSON.parse('{"path":"/interview/4_jvm.html","title":"Java总结-JVM","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"JVM是如何运行的？","slug":"jvm是如何运行的","link":"#jvm是如何运行的","children":[]},{"level":2,"title":"说说JVM的内存模型？","slug":"说说jvm的内存模型","link":"#说说jvm的内存模型","children":[]},{"level":2,"title":"垃圾回收算法","slug":"垃圾回收算法","link":"#垃圾回收算法","children":[{"level":3,"title":"1、标记-清除","slug":"_1、标记-清除","link":"#_1、标记-清除","children":[]},{"level":3,"title":"2、标记-复制","slug":"_2、标记-复制","link":"#_2、标记-复制","children":[]},{"level":3,"title":"3、标记-压缩","slug":"_3、标记-压缩","link":"#_3、标记-压缩","children":[]}]},{"level":2,"title":"垃圾回收器","slug":"垃圾回收器","link":"#垃圾回收器","children":[]}],"git":{"updatedTime":1739198420000,"contributors":[{"name":"hanchen","username":"hanchen","email":"1154937362@qq.com","commits":4,"url":"https://github.com/hanchen"},{"name":"Clarence","username":"Clarence","email":"1154937362@qq.com","commits":2,"url":"https://github.com/Clarence"}]},"filePathRelative":"interview/4_jvm.md"}');export{g as comp,_ as data};
